<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TWO.4 – Infinity Clock</title>
  <script>
  /* dev hotfix: auto-create missing #ids to avoid null.innerHTML errors */
  (() => {
    const mk = (id) => {
      const el = document.createElement('div');
      el.id = id;
      el.style.display = 'none';  // 화면엔 보이지 않게
      document.addEventListener('DOMContentLoaded', () => {
        // body가 생기면 붙이기
        (document.body || document.documentElement).appendChild(el);
      });
      return el;
    };

    const gebi = document.getElementById.bind(document);
    document.getElementById = function(id){
      return gebi(id) || mk(id);
    };

    const dQS = Document.prototype.querySelector;
    Document.prototype.querySelector = function(sel){
      const el = dQS.call(this, sel);
      if (!el && sel.startsWith('#')) return mk(sel.slice(1));
      return el;
    };
  })();
  </script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@300;400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="seed-weather.css"/>

  <style>
    #app{position:relative; z-index:2}
    /* ========== Reset / Base ========== */
    *{margin:0;padding:0;box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      font-family:'Inter',sans-serif;
      background:#000;
      color:#fff;
      line-height:1.6;
      min-height:100vh;
      overflow-x:hidden;
    }

    /* ========== Background Video - 비율별 최적화 ========== */
    .video-background{
      position:fixed; 
      top: 0;
      left: 0;
      width: 100vw; 
      height: 100vh;
      object-fit: cover; 
      object-position: center center;
      z-index: 0;
      background: #000;
      pointer-events: none;
    }
    
    /* 세로 비율 (모바일) */
    @media (orientation: portrait) {
      .video-background{ 
        object-position: center 40%;
        transform: scale(1.1);
      }
    }
    
    /* 가로 비율 (데스크톱) - 가로축 중심 */
    @media (orientation: landscape) {
      .video-background{ 
        object-position: center center;
        width: 100vw;
        height: 100vh;
        transform: scale(1);
      }
    }
    
    /* 초광각 화면 대응 */
    @media (orientation: landscape) and (min-aspect-ratio: 21/9) {
      .video-background{
        object-position: center center;
        transform: scale(1.2);
      }
    }
    
    /* 정사각형에 가까운 비율 */
    @media (min-aspect-ratio: 4/5) and (max-aspect-ratio: 5/4) {
      .video-background{
        object-position: center 35%;
        transform: scale(1.05);
      }
    }
    
    .video-overlay{
      position:fixed; 
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:rgba(0,0,0,.25);
      z-index:1; 
      pointer-events:none;
    }
    .video-overlay::before{
      content:""; 
      position:absolute; 
      inset:0; 
      pointer-events:none;
      background:
        radial-gradient(800px 600px at 70% 15%, rgba(139,92,246,.12), transparent 65%),
        radial-gradient(800px 600px at 25% 85%, rgba(34,211,238,.08), transparent 60%);
    }

    /* ========== Top-left Logo ========== */
    .brand-logo{
      position:fixed;
      top:12px; left:16px;
      z-index:1200; display:block;
      pointer-events:auto;
    }
    .brand-logo img{
      display:block;
      height:clamp(48px,5vw,80px);
      width:auto;
      filter:drop-shadow(0 3px 12px rgba(0,0,0,.4));
      opacity:.98;
    }
    @media (max-width:768px){
      .brand-logo{ top:10px; left:12px }
      .brand-logo img{ height:clamp(42px,11vw,64px); }
    }

    /* ========== Nav (Menu button) ========== */
    .nav{
      position:fixed;
      top:20px; right:24px;
      z-index:1200;
      display:flex; align-items:center; gap:28px;
    }

    .nav-links{
      display:flex;
      align-items:center;
      gap:20px;
      list-style:none;
      margin:0;
      padding:0;
      font-family:'Orbitron',sans-serif;
      text-transform:uppercase;
      letter-spacing:0.08em;
    }

    .nav-links a{
      color:rgba(188,248,255,.9);
      font-size:.78rem;
      font-weight:600;
      text-decoration:none;
      transition:color .2s ease, text-shadow .2s ease;
    }

    .nav-links a:hover,
    .nav-links a:focus{
      color:#ffffff;
      text-shadow:0 0 8px rgba(0,255,255,.6);
    }

    @media (max-width:1024px){
      .nav-links{display:none}
      .nav{gap:20px}
    }

    .menu-btn {
      position: relative;
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 14px 28px;
      border-radius: 999px;
      border: 1px solid rgba(139,92,246,.45);
      background: radial-gradient(circle at top left, rgba(139,92,246,.28), rgba(13,148,136,.18) 55%, rgba(2,132,199,.22));
      color: #e0f2fe;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 0.78rem;
      font-weight: 600;
      backdrop-filter: blur(18px);
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      transition: transform .3s ease, box-shadow .3s ease, border-color .3s ease;
    }

    .menu-btn::before {
      content: '';
      position: absolute;
      inset: 2px;
      border-radius: inherit;
      border: 1px solid rgba(255,255,255,.12);
      opacity: .65;
      pointer-events: none;
    }

    .menu-btn::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(120deg, transparent 10%, rgba(224,242,254,.15) 40%, transparent 70%);
      opacity: 0;
      transition: opacity .35s ease;
      pointer-events: none;
    }

    .menu-btn:hover,
    .menu-btn:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 18px 40px rgba(56,189,248,.35);
      border-color: rgba(125,211,252,.75);
      outline: none;
    }

    .menu-btn:hover::after,
    .menu-btn:focus-visible::after {
      opacity: 1;
    }

    .menu-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      text-align: left;
    }

    .menu-label {
      font-size: 0.82rem;
      letter-spacing: 0.2em;
    }

    .menu-sub {
      font-size: 0.62rem;
      letter-spacing: 0.08em;
      text-transform: none;
      color: rgba(226,232,240,.75);
      font-family: 'Inter', sans-serif;
    }

    .menu-accent {
      position: relative;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(240,249,255,.95), rgba(14,165,233,.45));
      box-shadow: 0 0 15px rgba(56,189,248,.55), inset 0 0 12px rgba(14,165,233,.4);
    }

    .menu-accent::before,
    .menu-accent::after {
      content: '';
      position: absolute;
      inset: 50%;
      transform: translate(-50%, -50%);
      border-radius: inherit;
      border: 1px solid rgba(7,89,133,.35);
    }

    .menu-accent::before {
      width: 80%;
      height: 80%;
    }

    .menu-accent::after {
      width: 45%;
      height: 45%;
      background: rgba(14,165,233,.3);
      box-shadow: 0 0 8px rgba(14,165,233,.45);
    }

    @media (max-width: 768px) {
      .menu-btn {
        padding: 12px 22px;
        gap: 14px;
        font-size: 0.72rem;
      }

      .menu-label {
        font-size: 0.76rem;
      }

      .menu-sub {
        font-size: 0.58rem;
      }

      .menu-accent {
        width: 30px;
        height: 30px;
      }
    }

    /* ========== Infinity Clock ========== */
    .infinity-clock{
      position:absolute;
      top: clamp(4px, 1.5vh, 12px);
      left:50%; transform:translateX(-50%);
      display:flex; flex-direction:column; align-items:center;
      gap: clamp(3px, .6vh, 6px);
      pointer-events:none; z-index:1200;
    }
    .inf-svg{ width:clamp(200px,35vw,400px); height:auto }
    .esc{ 
      font:600 clamp(13px,2.4vw,17px) 'Space Grotesk',system-ui,sans-serif; 
      fill:rgba(255,255,255,.85); 
      letter-spacing:1.5px 
    }
    .inf-base{ 
      fill:none; 
      stroke:rgba(255,255,255,.12); 
      stroke-width:6; 
      stroke-linecap:round 
    }
    .inf-prog{ 
      fill:none; 
      stroke:url(#inf-grad); 
      stroke-width:6; 
      stroke-linecap:round 
    }
    .inf-cursor{ fill:rgba(255,255,255,.9) }
    .inf-mark{ fill:rgba(255,255,255,.35) }
    .inf-digital{
      font-family:'Space Grotesk',system-ui,sans-serif; 
      font-weight:500;
      font-size:clamp(12px,1.8vw,16px); 
      color:rgba(255,255,255,.95); 
      letter-spacing:1px;
      background:rgba(0,0,0,.15);
      padding: clamp(6px,1vw,10px) clamp(10px,1.8vw,16px);
      border-radius:8px; 
      border:1px solid rgba(255,255,255,.06); 
      backdrop-filter:blur(8px)
    }
    .time-quote{
      font-family:'Space Grotesk',system-ui,sans-serif; 
      font-weight:300;
      font-size:clamp(9px,1.2vw,11px); 
      color:rgba(255,255,255,.55);
      text-align:center; 
      margin-top: clamp(4px,.8vh,8px);
      line-height:1.3; 
      letter-spacing:.2px; 
      font-style:italic
    }
    @media (max-width:768px){
      .infinity-clock{ top: clamp(2px,1vh,8px) }
      .inf-svg{ width:clamp(280px,85vw,400px) }
    }

    /* ========== Main Hero Section - 배경이 보이도록 ========== */
    .hero-section{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      z-index:1;
      background:transparent;
    }

    .hero-content{
      text-align:center;
      max-width:800px;
      padding:20px;
      margin-top:100px;
    }

    .hero-subtitle{
      font-size:clamp(0.95rem, 2.4vw, 1.3rem);
      color:rgba(255,255,255,.75);
      margin-bottom:3rem;
      line-height:1.6;
      font-weight:300;
      font-style:italic;
      text-shadow:0 2px 8px rgba(0,0,0,.3);
    }

    /* ========== Content - 차트 영역 ========== */
    .content-section{
      background:linear-gradient(135deg, rgba(0,0,0,.92), rgba(15,15,30,.95));
      backdrop-filter:blur(20px);
      min-height:100vh;
      padding:80px 20px 120px;
      border-top:2px solid rgba(139,92,246,.3);
      position:relative; 
      z-index:2;
      box-shadow:0 -20px 40px rgba(0,0,0,.3);
    }

    .container{ 
      max-width:1200px; 
      margin:0 auto 
    }

    .section-title{
      font-family:'Space Grotesk',sans-serif;
      font-size:clamp(2rem, 6vw, 3.5rem); 
      font-weight:700; 
      text-align:center; 
      margin-bottom:3rem;
      background:linear-gradient(135deg, #8b5cf6, #06b6d4);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      text-shadow:0 0 30px rgba(139,92,246,.6);
    }

    .section-content{ 
      display:grid; 
      gap:4rem;
      margin-bottom:4rem;
    }

    /* 차트 컨테이너 - 더 미래적으로 */
    .chart-container{
      background:linear-gradient(135deg, rgba(139,92,246,.08), rgba(59,130,246,.05));
      border:2px solid rgba(139,92,246,.25);
      border-radius:24px;
      padding:2.5rem 2.5rem 3.75rem;
      box-shadow:
        0 25px 50px rgba(0,0,0,.4),
        inset 0 1px 0 rgba(255,255,255,.1);
      min-height:650px;
      height:auto;
      position:relative;
      overflow:visible;
      margin-bottom:3.5rem;
    }

    .chart-container::before{
      content:''; 
      position:absolute; 
      inset:-2px; 
      background:linear-gradient(45deg, transparent, rgba(139,92,246,.15), transparent);
      border-radius:24px;
      z-index:-1;
      animation:borderPulse 4s ease-in-out infinite;
    }

    @keyframes borderPulse{ 
      0%,100%{opacity:.3} 
      50%{opacity:.8} 
    }

    .chart-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:24px;
      margin-bottom:28px;
      padding:18px 22px;
      border-radius:18px;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(15,23,42,.55);
      box-shadow:0 16px 38px rgba(15,23,42,.28);
      backdrop-filter:blur(20px);
    }

    .chart-controls{
      display:flex;
      gap:18px;
      align-items:center;
      flex-wrap:wrap;
    }

    .chart-range-toggle{
      display:flex;
      gap:10px;
      background:rgba(139,92,246,.12);
      padding:6px;
      border-radius:14px;
      border:1px solid rgba(139,92,246,.25);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
    }

    .chart-range-btn{
      position:relative;
      border:none;
      padding:8px 16px;
      border-radius:10px;
      font-family:'Space Grotesk',sans-serif;
      font-weight:600;
      font-size:13px;
      letter-spacing:.03em;
      color:rgba(255,255,255,.78);
      background:transparent;
      cursor:pointer;
      transition:background .25s, color .25s, box-shadow .25s;
    }

    .chart-range-btn::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:linear-gradient(120deg, rgba(139,92,246,.25), rgba(56,189,248,.25));
      opacity:0;
      transition:opacity .25s;
      z-index:-1;
    }

    .chart-range-btn:hover,
    .chart-range-btn:focus{
      color:#fff;
      outline:none;
    }

    .chart-range-btn:hover::after,
    .chart-range-btn:focus::after{
      opacity:.35;
    }

    .chart-range-btn.active{
      color:#fff;
      background:rgba(139,92,246,.3);
      box-shadow:0 0 18px rgba(139,92,246,.35);
    }

    .chart-range-btn.active::after{
      opacity:.55;
    }

    .chart-selector{
      background:rgba(139,92,246,.15);
      border:2px solid rgba(139,92,246,.3);
      color:#fff; 
      padding:10px 16px; 
      border-radius:12px; 
      font-size:14px; 
      outline:none;
      transition:.25s;
      font-family:'Space Grotesk',sans-serif;
      font-weight:500;
    }
    .chart-selector:focus{ 
      border-color:rgba(139,92,246,.6); 
      box-shadow:0 0 20px rgba(139,92,246,.4) 
    }
    .chart-selector option{ 
      background:#000; 
      color:#fff 
    }

    .chart-legend{
      display:flex;
      gap:18px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .legend-item{ 
      display:flex; 
      align-items:center; 
      gap:8px; 
      font-size:12px; 
      font-weight:600; 
      color:rgba(255,255,255,.85); 
      cursor:pointer; 
      transition:.25s;
      padding:6px 12px;
      border-radius:8px;
      background:rgba(0,0,0,.3);
    }
    .legend-item:hover{ 
      color:#fff; 
      background:rgba(139,92,246,.2);
      transform:translateY(-2px) 
    }
    .legend-color{
      width:12px;
      height:3px;
      border-radius:2px
    }
    .price-display{
      display:none;
    }

    .cosmos-chart-canvas{
      width:100%; 
      height:500px; 
      background:rgba(0,0,0,.4); 
      border-radius:16px;
      border:2px solid rgba(139,92,246,.15); 
      cursor:crosshair;
      box-shadow:inset 0 4px 20px rgba(0,0,0,.3);
    }

    /* 뉴스/커뮤니티 카드들 */
    .news-grid,.coin-grid{ 
      display:grid; 
      grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); 
      gap:2.5rem 
    }
    
    .news-card,.coin-card{
      background:linear-gradient(135deg, rgba(139,92,246,.08), rgba(59,130,246,.05));
      border:2px solid rgba(139,92,246,.2);
      border-radius:20px; 
      padding:2.5rem; 
      transition:.3s; 
      backdrop-filter:blur(15px);
      box-shadow:0 10px 30px rgba(0,0,0,.2);
    }
    .news-card:hover,.coin-card:hover{
      background:linear-gradient(135deg, rgba(139,92,246,.15), rgba(59,130,246,.08));
      border-color:rgba(139,92,246,.4);
      transform:translateY(-8px); 
      box-shadow:0 20px 40px rgba(139,92,246,.3);
    }
    .card-title{ 
      color:#8b5cf6; 
      font-size:1.3rem; 
      font-weight:700; 
      margin-bottom:1.2rem;
      font-family:'Space Grotesk',sans-serif;
    }
    .card-content{ 
      color:rgba(255,255,255,.85);
      line-height:1.6;
    }

    /* ========== Menu Overlay ========== */
    .menu-overlay{
      position:fixed; 
      top:0; 
      right:-450px; 
      width:450px; 
      height:100vh;
      background:rgba(0,0,0,.97); 
      backdrop-filter:blur(30px);
      border-left:2px solid rgba(139,92,246,.4);
      z-index:2000; 
      transition:right .4s ease;
      padding:80px 40px 40px; 
      overflow-y:auto;
    }
    .menu-overlay.active{ right:0 }
    .menu-close{
      position:absolute; 
      top:30px; 
      right:30px; 
      width:40px; 
      height:40px; 
      cursor:pointer;
      display:flex; 
      align-items:center; 
      justify-content:center;
      color:#8b5cf6; 
      font-size:24px; 
      transition:.25s; 
      border-radius:50%;
      border:1px solid rgba(139,92,246,.35);
    }
    .menu-close:hover{ 
      color:#fff; 
      background:rgba(139,92,246,.2); 
      border-color:rgba(139,92,246,.65) 
    }
    .menu-section{ margin-bottom:30px }
    .menu-items{ list-style:none }
    .menu-item{ margin-bottom:6px }
    .menu-link{
      color:rgba(255,255,255,.85); 
      text-decoration:none; 
      font-size:14px; 
      font-weight:500;
      font-family:'Space Grotesk',sans-serif; 
      text-transform:uppercase; 
      letter-spacing:1px;
      transition:.25s; 
      display:block; 
      padding:10px 16px; 
      border-radius:8px; 
      position:relative;
    }
    .menu-link:hover{ 
      color:#fff; 
      background:rgba(139,92,246,.1); 
      transform:translateX(8px); 
      text-shadow:0 0 15px rgba(139,92,246,.6) 
    }
    .korean-desc{ 
      color:rgba(139,92,246,.85); 
      font-size:12px; 
      font-weight:400; 
      text-transform:none; 
      letter-spacing:0; 
      margin-left:8px; 
      display:none 
    }
    .menu-link:hover .korean-desc{ display:inline }
    .menu-link.featured{
      background:linear-gradient(135deg,rgba(139,92,246,.15),rgba(168,85,247,.1));
      border:1px solid rgba(139,92,246,.3); 
      font-weight:600; 
      color:rgba(139,92,246,.92);
    }
    .menu-link.featured:hover{
      background:linear-gradient(135deg,rgba(139,92,246,.25),rgba(168,85,247,.15));
      border-color:rgba(139,92,246,.6); 
      color:#fff; 
      box-shadow:0 0 20px rgba(139,92,246,.4);
    }

    /* ========== X-Talk Button ========== */
    .chat-button{
      position:fixed;
      bottom:28px;
      right:28px;
      background:linear-gradient(135deg, rgba(139,92,246,.15), rgba(59,130,246,.1));
      color:#fff; 
      border:2px solid rgba(139,92,246,.4);
      padding:16px 28px; 
      border-radius:16px; 
      cursor:pointer;
      box-shadow:0 8px 32px rgba(139,92,246,.2); 
      z-index:1000; 
      font-weight:600; 
      font-size:15px;
      transition:.3s ease; 
      backdrop-filter:blur(20px);
      font-family:'Space Grotesk',sans-serif;
      letter-spacing:0.5px;
    }
    .chat-button:hover{ 
      background:linear-gradient(135deg, rgba(139,92,246,.25), rgba(59,130,246,.15));
      border-color:rgba(139,92,246,.6);
      box-shadow:0 12px 40px rgba(139,92,246,.35);
      transform:translateY(-3px);
    }
    .chat-button::before{
      content:'';
      position:absolute;
      inset:0;
      background:linear-gradient(135deg, transparent, rgba(255,255,255,.1), transparent);
      border-radius:14px;
      opacity:0;
      transition:.3s ease;
    }
    .chat-button:hover::before{
      opacity:1;
    }

    .chat-modal{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(10,0,30,.82);
      backdrop-filter:blur(18px);
      -webkit-backdrop-filter:blur(18px);
      opacity:0;
      visibility:hidden;
      transition:opacity .25s ease, visibility .25s ease;
      z-index:1400;
      padding:24px;
    }
    .chat-modal.open{
      opacity:1;
      visibility:visible;
    }
    .chat-modal-card{
      position:relative;
      width:min(360px,90vw);
      padding:32px 28px;
      border-radius:20px;
      background:rgba(18,4,40,.95);
      border:1px solid rgba(139,92,246,.35);
      box-shadow:0 20px 60px rgba(15,0,40,.55);
      text-align:center;
      font-family:'Space Grotesk',sans-serif;
    }
    .chat-modal-card h3{
      font-size:20px;
      letter-spacing:1.5px;
      text-transform:uppercase;
      color:#e8ddff;
      margin-bottom:6px;
    }
    .chat-modal-subtitle{
      font-size:13px;
      color:rgba(200,180,255,.75);
      letter-spacing:1px;
      margin-bottom:22px;
    }
    .chat-options{
      display:flex;
      gap:16px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .chat-option{
      flex:1 1 130px;
      padding:14px 18px;
      border-radius:14px;
      border:1px solid rgba(139,92,246,.4);
      background:rgba(59,130,246,.1);
      color:#e7ffff;
      font-weight:600;
      letter-spacing:1px;
      cursor:pointer;
      transition:.25s ease;
    }
    .chat-option:hover{
      transform:translateY(-2px);
      box-shadow:0 12px 30px rgba(59,130,246,.25);
    }
    .chat-option.kakao{
      background:linear-gradient(135deg,rgba(255,221,0,.15),rgba(255,180,0,.08));
      color:#ffe066;
      border-color:rgba(255,196,0,.45);
    }
    .chat-option.kakao:hover{
      box-shadow:0 12px 32px rgba(255,196,0,.3);
    }
    .chat-option.zx{
      background:linear-gradient(135deg,rgba(239,68,68,.08),rgba(190,24,93,.12));
      color:#ff6b81;
      border-color:rgba(239,68,68,.45);
    }
    .chat-option.zx:hover{
      box-shadow:0 12px 32px rgba(239,68,68,.35);
    }
    .chat-warning{
      margin-top:20px;
      font-size:14px;
      font-weight:700;
      letter-spacing:1px;
      color:#ff4d6d;
      opacity:0;
      transform:translateY(8px);
      transition:opacity .2s ease, transform .2s ease;
      min-height:20px;
    }
    .chat-warning.active{
      opacity:1;
      transform:translateY(0);
    }
    .chat-modal-close{
      position:absolute;
      top:12px;
      right:14px;
      background:transparent;
      border:none;
      color:rgba(231,255,255,.55);
      font-size:22px;
      cursor:pointer;
      transition:color .2s ease;
    }
    .chat-modal-close:hover{
      color:#fff;
    }
    
    /* ========== Seed Container ========== */
    #seed-container{
      position:fixed;
      bottom:10%;
      left:8%;
      width:120px;
      height:130px;
      opacity:.85;
      transition:opacity .3s ease, transform .2s ease;
      transform-origin:bottom left;
      z-index:900;
        cursor:pointer;
    }
    #seed-container:hover{
      opacity:1;
      transform:scale(1.05);
    }
    #seed-container:active{
      transform:scale(0.98);
    }
    #planet-canvas{width:100px;height:100px;}
    .seed-tooltip{
      position:absolute;
      top:92px;
      left:50%;
      transform:translateX(-50%) translateY(5px);
      color:#00ffcc;
      font-size:11px;
      font-weight:700;
      font-family:'Arial',sans-serif;
      letter-spacing:1.5px;
      text-transform:uppercase;
      white-space:nowrap;
      opacity:0;
      visibility:hidden;
      transition:opacity .4s ease, visibility .4s ease, transform .4s ease;
      pointer-events:none;
      text-shadow:
        0 0 10px rgba(0,255,204,.8),
        0 0 20px rgba(0,255,204,.4),
        0 0 30px rgba(0,255,204,.2);
    }
    #seed-container:hover .seed-tooltip{
      opacity:1;
      visibility:visible;
      transform:translateX(-50%) translateY(0);
    }

    /* ========== Mobile tweaks ========== */
    @media (max-width:768px){
      .nav{ top:16px; right:16px }
      .menu-overlay{ width:100%; right:-100% }
      .content-section{ padding:60px 20px 100px }
      .section-title{ font-size:2rem }
      .chart-header{ flex-direction:column; gap:14px; align-items:stretch; padding:16px 18px }
      .chart-controls{ width:100%; justify-content:space-between }
      .chart-legend{ justify-content:flex-start; gap:10px }
      .legend-item{ font-size:10px; gap:4px; padding:4px 8px }
      .chart-container{ padding:1.75rem 1.5rem 3rem; min-height:auto; margin-bottom:2.75rem }
      .cosmos-chart-canvas{ width:100%; height:auto }
      .hero-title{ font-size:2.5rem }
    }
    
    @media (max-width:768px) and (orientation:portrait){
      .cosmos-chart-canvas{ aspect-ratio:1/1.618 }
    }
    
    @media (max-width:600px){
      #seed-container{transform:scale(.8);}
      .seed-tooltip{font-size:9px;}
    }

    /* ========== Core Architecture Section ========== */
    #two4-core-architecture{
      position:relative;
      z-index:2;
      margin:120px auto 80px;
      width: min(1100px, 92vw);
    }

    #two4-core-architecture .core-architecture-frame{
      position:relative;
      width:100%;
      aspect-ratio: 16 / 9;
      border-radius:32px;
      border:1px solid rgba(148,163,184,.25);
      background:linear-gradient(160deg, rgba(15,23,42,.92), rgba(8,11,21,.92));
      overflow:hidden;
      box-shadow:0 30px 60px rgba(15,23,42,.55);
    }

    #two4-core-architecture canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    #two4-core-architecture .core-architecture-status{
      position:absolute;
      top:32px;
      right:32px;
      font:500 11px 'Rajdhani', 'Inter', sans-serif;
      letter-spacing:2px;
      color:#9ca3af;
      display:flex;
      align-items:center;
      gap:10px;
      z-index:3;
    }

    #two4-core-architecture .core-architecture-dot{
      width:8px;
      height:8px;
      border-radius:999px;
      background:#4ade80;
      box-shadow:0 0 12px rgba(74,222,128,.75);
      animation:core-architecture-pulse 2s ease-in-out infinite;
    }

    @keyframes core-architecture-pulse{
      0%,100%{opacity:1;}
      50%{opacity:.3;}
    }

    @media (max-width:768px){
      #two4-core-architecture{
        margin:100px auto 60px;
        width: min(100%, 94vw);
      }

      #two4-core-architecture .core-architecture-status{
        top:20px;
        right:20px;
        font-size:10px;
        letter-spacing:1.6px;
      }
    }
  </style>
</head>
<body>
  <!-- Background -->
  <video class="video-background" autoplay muted loop playsinline preload="metadata" id="bgVideo">
    <source src="/media/background1.mp4" type="video/mp4">
    <source src="/media/background.mp4" type="video/mp4">
  </video>
  <div class="video-overlay"></div>

  <div id="app">

  <!-- Logo -->
  <a href="https://two4-production.up.railway.app" class="brand-logo" aria-label="TWO.4 home">
    <img src="/media/logo.png" alt="TWO.4 logo" />
  </a>

  <!-- Nav -->
  <nav class="nav">
    <ul class="nav-links">
      <li><a href="/menu/cosmos/">Crypto Market</a></li>
      <li><a href="#seed-weather">Cosmic Weather</a></li>
      <li><a href="/menu/orbits.html">Orbits</a></li>
      <li><a href="/menu/method.html">Method</a></li>
      <li><a href="/menu/psyche.html">Psyche</a></li>
      <li><a href="/menu/echoes/">Echoes</a></li>
      <li><a href="/menu/constellation.html">Constellation</a></li>
      <li><a href="/menu/auth/login/">Portal</a></li>
    </ul>
    <button type="button" class="menu-btn" id="menuButton" aria-label="Open menu">
      <span class="menu-text">
        <span class="menu-label">MENU</span>
        <span class="menu-sub">Cosmos Navigation</span>
      </span>
      <span class="menu-accent" aria-hidden="true"></span>
    </button>
  </nav>

  <!-- Infinity Clock -->
  <div class="infinity-clock">
    <svg class="inf-svg" viewBox="0 0 600 280">
      <defs>
        <linearGradient id="inf-grad" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0"    stop-color="#10b981"/>
          <stop offset="0.25" stop-color="#eab308"/>
          <stop offset="0.5"  stop-color="#f59e0b"/>
          <stop offset="0.75" stop-color="#ef4444"/>
          <stop offset="1"    stop-color="#dc2626"/>
        </linearGradient>
      </defs>
      <text x="300" y="32" text-anchor="middle" class="esc">E-SC</text>
      <path id="infBase" d="M300 140 C250 60 110 60 110 140 S250 220 300 140 S490 60 490 140 S350 220 300 140" class="inf-base"/>
      <path id="infProg" d="M300 140 C250 60 110 60 110 140 S250 220 300 140 S490 60 490 140 S350 220 300 140" class="inf-prog"/>
      <circle id="infCursor" r="4" class="inf-cursor"/>
      <circle id="markA" r="3" class="inf-mark"/>
      <circle id="markB" r="3" class="inf-mark"/>
    </svg>
    <div class="inf-digital" id="infDigital">AM 00:00:00</div>
    <div class="time-quote" id="timeQuote">Time is what we want most, but what we use worst.</div>
  </div>

  <!-- Hero Section - 배경이 보이는 영역 -->
  <main class="hero-section" id="home">
    <div class="hero-content">
      <p class="hero-subtitle">"In the realm of infinite possibilities, every decision echoes through eternity.<br>Trade not just with data, but with wisdom."</p>
    </div>
  </main>

  <!-- Content - 차트 영역 -->
  <section class="content-section">
    <div class="container">
      <div class="section-content">
        <h2 class="section-title">COSMOS CHART</h2>
        <div class="chart-container">
          <div class="chart-header">
            <div class="chart-controls">
              <div class="chart-range-toggle" id="timeRange">
                <button type="button" class="chart-range-btn" data-range="1d">1D</button>
                <button type="button" class="chart-range-btn" data-range="3d">3D</button>
                <button type="button" class="chart-range-btn active" data-range="7d">7D</button>
                <button type="button" class="chart-range-btn" data-range="1m">1M</button>
                <button type="button" class="chart-range-btn" data-range="3m">3M</button>
              </div>
              <select id="chartType" class="chart-selector">
                <option value="multi" selected>Multi Coins</option>
                <option value="single">Single Coin</option>
              </select>
              <span class="price-display" id="marketCap" aria-hidden="true"></span>
            </div>
            <div class="chart-legend" id="chartLegend"></div>
          </div>
          <canvas id="cosmosChart" class="cosmos-chart-canvas"></canvas>
        </div>
      </div>

      <section id="seed-weather" class="section-content cosmic-section">
        <h2 class="section-title">Two.4 — Seed AI 예측 날씨</h2>
        <div id="seed-weather-root"></div>
      </section>

      <div class="section-content" style="text-align:center;">
        <h2 class="section-title">Community Hub</h2>
        <p style="font-size:1.2rem;margin-bottom:2rem;color:rgba(255,255,255,.7)">트레이더들이 모이는 지식 공유 공간</p>
        <div style="display:flex;justify-content:center;gap:2rem;flex-wrap:wrap">
          <div class="coin-card" style="max-width:300px;">
            <h3 class="card-title">Strategy Lab</h3>
            <div class="card-content">AI 기반 전략 분석과 백테스팅 결과 공유</div>
          </div>
          <div class="coin-card" style="max-width:300px;">
            <h3 class="card-title">Signal Exchange</h3>
            <div class="card-content">실시간 시그널과 시장 분석 토론</div>
          </div>
          <div class="coin-card" style="max-width:300px;">
            <h3 class="card-title">Oracle Q&A</h3>
            <div class="card-content">AI 오라클과 함께하는 질의응답</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Menu Overlay -->
  <div class="menu-overlay" id="menuOverlay" aria-hidden="true">
    <div class="menu-close" id="menuClose" aria-label="Close">×</div>
    <div class="menu-section">
      <ul class="menu-items">
<li class="menu-item"><a href="menu/cosmos/" class="menu-link">COSMOS CRYPTO</a><span class="korean-desc">차트</span></li>
<li class="menu-item"><a href="#seed-weather" class="menu-link">COSMIC WEATHER<span class="korean-desc">시장 기상</span></a></li>
<li class="menu-item"><a href="menu/cosmos/" class="menu-link">CRYPTO MARKET<span class="korean-desc">암호화폐 시세</span></a></li>
<li class="menu-item"><a href="menu/orbits.html" class="menu-link">ORBITS (SIGNALS / INDICATORS)<span class="korean-desc">지표/신호</span></a></li>
<li class="menu-item"><a href="menu/method.html" class="menu-link">METHOD (TECHNIQUE)<span class="korean-desc">매매 기법</span></a></li>
<li class="menu-item"><a href="menu/psyche.html" class="menu-link">PSYCHE<span class="korean-desc">마음과 철학, 멘탈</span></a></li>
</ul>
</div>
<div class="menu-section">
  <ul class="menu-items">
    <li class="menu-item"><a href="menu/echoes/" class="menu-link">ECHOES (OBSERVATIONS / NEWS)<span class="korean-desc">사건의 메아리, 관찰 기록</span></a></li>
    <li class="menu-item"><a href="menu/constellation.html" class="menu-link">CONSTELLATION (COMMUNITY)<span class="korean-desc">사용자 커뮤니티</span></a></li>
    <li class="menu-item"><a href="menu/beacons.html" class="menu-link">BEACONS (ALERTS)<span class="korean-desc">주의</span></a></li>
</ul>
</div>
<div class="menu-section">
  <ul class="menu-items">
    <li class="menu-item"><a href="https://open.kakao.com/o/gakOu7Og" target="_blank" rel="noopener" class="menu-link featured">OPEN CHAT<span class="korean-desc">카카오 오픈채팅</span></a></li>
    <li class="menu-item">
      <a href="/ai-chat.html" class="menu-link featured">
        SEED AI CHAT<span class="korean-desc">AI 채팅</span>
      </a>
    </li>
    <li class="menu-item"><a href="/menu/auth/login/" class="menu-link featured">PORTAL<span class="korean-desc">(가입/로그인/로그아웃)</span></a></li>

      </ul>
    </div>
  </div>

  <button class="chat-button" id="chatButton">X-Talk</button>
  <div class="chat-modal" id="chatModal" aria-hidden="true">
    <div class="chat-modal-card" role="dialog" aria-modal="true" aria-labelledby="chatModalTitle">
      <button class="chat-modal-close" id="chatClose" aria-label="닫기">×</button>
      <h3 id="chatModalTitle">X-Talk Gateway</h3>
      <p class="chat-modal-subtitle">접속 채널을 선택하세요</p>
      <div class="chat-options">
        <button class="chat-option kakao" id="chatKakao" type="button">Kakao</button>
        <button class="chat-option zx" id="chatZx" type="button">Zx-Agent</button>
      </div>
      <p class="chat-warning" id="chatWarning" role="alert" aria-live="assertive"></p>
    </div>
  </div>
  <div id="seed-container">
    <canvas id="planet-canvas"></canvas>
    <div class="seed-tooltip">C.518D - Seed Ai</div>
  </div>

  <section id="two4-core-architecture">
    <div class="core-architecture-frame">
      <canvas id="core-architecture-canvas" aria-hidden="true"></canvas>
      <div class="core-architecture-status">
        <span class="core-architecture-dot" aria-hidden="true"></span>
        SYSTEM OPERATIONAL
      </div>
    </div>
  </section>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="seed-weather.js" defer></script>
  <script>
    function createSeedPlanet() {
      const canvas = document.getElementById('planet-canvas');
      if (!canvas) return;
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
      renderer.setSize(100, 100);
      renderer.setClearColor(0x000000, 0);
      const geometry = new THREE.SphereGeometry(1, 12, 8);
      const planetMaterial = new THREE.MeshBasicMaterial({ color: 0x9966ff, wireframe: true, opacity: 0.3, transparent: true });
      const planet = new THREE.Mesh(geometry, planetMaterial);
      scene.add(planet);
      const auraGeometry1 = new THREE.SphereGeometry(1.2, 10, 6);
      const auraMaterial1 = new THREE.MeshBasicMaterial({ color: 0xbb88ff, wireframe: true, opacity: 0.25, transparent: true });
      const aura1 = new THREE.Mesh(auraGeometry1, auraMaterial1);
      scene.add(aura1);
      const auraGeometry2 = new THREE.SphereGeometry(1.5, 8, 5);
      const auraMaterial2 = new THREE.MeshBasicMaterial({ color: 0xdd99ff, wireframe: true, opacity: 0.15, transparent: true });
      const aura2 = new THREE.Mesh(auraGeometry2, auraMaterial2);
      scene.add(aura2);
      const auraGeometry3 = new THREE.SphereGeometry(1.8, 6, 4);
      const auraMaterial3 = new THREE.MeshBasicMaterial({ color: 0xeeaaff, wireframe: true, opacity: 0.1, transparent: true });
      const aura3 = new THREE.Mesh(auraGeometry3, auraMaterial3);
      scene.add(aura3);
      const particleCount = 80;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        const phi = Math.random() * Math.PI * 2;
        const theta = Math.random() * Math.PI;
        const radius = 1.6 + Math.random() * 0.8;
        positions[i * 3] = radius * Math.sin(theta) * Math.cos(phi);
        positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
        positions[i * 3 + 2] = radius * Math.cos(theta);
      }
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMaterial = new THREE.PointsMaterial({ color: 0x9966ff, size: 0.03, opacity: 0.5, transparent: true });
      const particleSystem = new THREE.Points(particles, particleMaterial);
      scene.add(particleSystem);
      camera.position.z = 3;
      let mouseX = 0;
      let mouseY = 0;
      let isHovered = false;
      canvas.addEventListener('mouseenter', () => { isHovered = true; });
      canvas.addEventListener('mouseleave', () => { isHovered = false; });
      canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      });
      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        planet.rotation.y += 0.008;
        planet.rotation.x += 0.003;
        aura1.rotation.y -= 0.006;
        aura1.rotation.x += 0.002;
        aura2.rotation.y += 0.004;
        aura2.rotation.x -= 0.001;
        aura3.rotation.y -= 0.003;
        particleSystem.rotation.y += 0.005;
        particleSystem.rotation.x += 0.002;
        auraMaterial1.opacity = 0.25 + Math.sin(time * 2) * 0.1;
        auraMaterial2.opacity = 0.15 + Math.cos(time * 1.8) * 0.08;
        auraMaterial3.opacity = 0.1 + Math.sin(time * 2.5) * 0.05;
        particleMaterial.opacity = 0.5 + Math.sin(time * 3) * 0.15;
        if (isHovered) {
          planet.rotation.y += mouseX * 0.015;
          planet.rotation.x += mouseY * 0.015;
          planetMaterial.opacity = 0.6;
          auraMaterial1.opacity = Math.min(0.5, auraMaterial1.opacity + 0.2);
          auraMaterial2.opacity = Math.min(0.4, auraMaterial2.opacity + 0.15);
          auraMaterial3.opacity = Math.min(0.3, auraMaterial3.opacity + 0.1);
          planet.scale.setScalar(1.08);
          aura1.scale.setScalar(1.1);
          aura2.scale.setScalar(1.15);
          aura3.scale.setScalar(1.2);
        } else {
          planetMaterial.opacity = 0.3;
          planet.scale.setScalar(1.0);
          aura1.scale.setScalar(1.0);
          aura2.scale.setScalar(1.0);
          aura3.scale.setScalar(1.0);
        }
        renderer.render(scene, camera);
      }
      animate();
    }
    createSeedPlanet();
  </script>

  <script>
    /* 비디오 자동재생 보장 */
(function () {
  const v = document.getElementById('bgVideo');
      if (!v) return;
      const tryPlay = () => {
        const p = v.play && v.play();
        if (p && p.catch) p.catch(() => setTimeout(tryPlay, 400));
      };
      if (document.visibilityState === 'visible') tryPlay();
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') tryPlay();
      });
    })();

    // 비디오 소스 선택 - 비율별 최적화
    function chooseVideoSource(){
      const v=document.getElementById('bgVideo');
      if(!v) return;
      
      // 데이터 절약 모드 체크
      const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const saveData = conn && conn.saveData;
      const reduceData = window.matchMedia('(prefers-reduced-data: reduce)').matches;
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // 데이터 절약이 아닌 경우에만 비디오 표시
      if (!saveData && !reduceData && !reduceMotion) {
        const portrait = window.matchMedia('(orientation: portrait)').matches;
        const aspectRatio = window.innerWidth / window.innerHeight;
        
        let desired;
        if (portrait || aspectRatio < 1) {
          // 세로 모드 → background1.mp4 (새 버전)
          desired = '/media/background1.mp4';
        } else {
          // 가로 모드 → background.mp4 (기존 가로 버전)
          desired = '/media/background.mp4';
        }
        
        const current = v.currentSrc || '';
        const currentFile = current.split('/').pop();
        const desiredFile = desired.split('/').pop();
        
        if (currentFile !== desiredFile) {
          console.log(`Switching video: ${currentFile} → ${desiredFile}`);
          v.innerHTML = '';
          const source = document.createElement('source');
          source.src = desired;
          source.type = 'video/mp4';
          v.appendChild(source);
          v.load();
          v.play().catch(e=>console.log('Video play failed:', e));
        }
        v.style.display = 'block';
      } else {
        // 데이터 절약 모드일 때는 비디오 숨김
        v.style.display = 'none';
      }
    }
    
    chooseVideoSource();
    window.addEventListener('resize', chooseVideoSource);
    window.addEventListener('orientationchange', chooseVideoSource);

    /* 메뉴 토글 */
    const menuBtn=document.getElementById('menuButton');
    const menuClose=document.getElementById('menuClose');
    const menuOverlay=document.getElementById('menuOverlay');
    
    function toggleMenu(){ 
      menuOverlay.classList.toggle('active') 
    }
    
    menuBtn && menuBtn.addEventListener('click',toggleMenu);
    menuClose && menuClose.addEventListener('click',toggleMenu);
    
    document.addEventListener('click',e=>{
      if(menuOverlay && menuBtn && !menuOverlay.contains(e.target) && !menuBtn.contains(e.target)){
        menuOverlay.classList.remove('active');
      }
    });

    // 하단 채팅 버튼
    const chatButton=document.getElementById('chatButton');
    const chatModal=document.getElementById('chatModal');
    const chatClose=document.getElementById('chatClose');
    const chatKakao=document.getElementById('chatKakao');
    const chatZx=document.getElementById('chatZx');
    const chatWarning=document.getElementById('chatWarning');

    const hideChatModal=()=>{
      chatModal?.classList.remove('open');
      chatModal?.setAttribute('aria-hidden','true');
    };

    const showChatModal=()=>{
      chatWarning?.classList.remove('active');
      if(chatWarning) chatWarning.textContent='';
      chatModal?.classList.add('open');
      chatModal?.setAttribute('aria-hidden','false');
    };

    chatButton?.addEventListener('click',showChatModal);
    chatClose?.addEventListener('click',hideChatModal);
    chatModal?.addEventListener('click',e=>{
      if(e.target===chatModal) hideChatModal();
    });
    document.addEventListener('keydown',e=>{
      if(e.key==='Escape'&&chatModal?.classList.contains('open')) hideChatModal();
    });
    chatKakao?.addEventListener('click',()=>{
      window.open('https://open.kakao.com/o/gakOu7Og','_blank','noopener');
      hideChatModal();
    });
    chatZx?.addEventListener('click',()=>{
      if(chatWarning){
        chatWarning.textContent='Blacknet access blocked – License not granted';
        chatWarning.classList.add('active');
      }
    });

    /* ===== Infinity Clock ===== */
    const dailyQuotes=[
      "Time is what we want most, but what we use worst.",
      "Lost time is never found again.",
      "Time flies over us, but leaves its shadow behind.",
      "The two most powerful warriors are patience and time.",
      "Time is a created thing. Say 'I don't have time,' not 'I don't have time.'",
      "Time you enjoy wasting is not wasted time.",
      "Yesterday is gone. Tomorrow has not yet come. We have only today."
    ];
    
    function initClock(){
      const base=document.getElementById('infBase');
      const prog=document.getElementById('infProg');
      const cursor=document.getElementById('infCursor');
      const digital=document.getElementById('infDigital');
      const timeQuote=document.getElementById('timeQuote');
      const markA=document.getElementById('markA');
      const markB=document.getElementById('markB');
      
      if(!base||!prog) return;

      const totalLength=base.getTotalLength();
      prog.style.strokeDasharray=`0 ${totalLength}`;
      
      const secondsToLength=sec=>((sec%60)/60)*totalLength;
      
      const place=(el,len)=>{ 
        const p=base.getPointAtLength(len); 
        el.setAttribute('cx',p.x); 
        el.setAttribute('cy',p.y) 
      };
      
      place(markA,secondsToLength(15));
      place(markB,secondsToLength(45));

      function update(){
        const now=new Date();
        const s=now.getSeconds();
        const len=secondsToLength(s);
        prog.style.strokeDasharray=`${len} ${totalLength-len}`;
        place(cursor,len);

        const h=now.getHours(), m=now.getMinutes();
        const hh=String(((h+11)%12)+1).padStart(2,'0');
        const mm=String(m).padStart(2,'0');
        const ss=String(s).padStart(2,'0');
        const ampm=h<12?'AM':'PM';
        digital.textContent=`${ampm} ${hh}:${mm}:${ss}`;

        const dow=now.getDay(); 
        const idx=dow===0?6:dow-1;
        timeQuote.textContent=dailyQuotes[idx];
      }
      
      update(); 
      setInterval(update,1000);
    }

    /* ===== COSMOS 차트 엔진 ===== */
    let chartCanvas=null, chartContext=null, currentData=new Map();

    function formatPrice(value){
      if(!Number.isFinite(value)) return '-';
      return `$${value.toFixed(2)}`;
    }
    
    const cryptoConfig=[
      {id:'BTC',name:'BTC',color:'#ff9500',visible:true},
      {id:'ETH',name:'ETH',color:'#627eea',visible:true},
      {id:'BNB',name:'BNB',color:'#f0b90b',visible:true},
      {id:'SOL',name:'SOL',color:'#9945ff',visible:true},
      {id:'ADA',name:'ADA',color:'#0066cc',visible:true},
      {id:'XRP',name:'XRP',color:'#00d4aa',visible:true},
      {id:'AVAX',name:'AVAX',color:'#e84142',visible:true},
      {id:'DOGE',name:'DOGE',color:'#c2a633',visible:true},
      {id:'LINK',name:'LINK',color:'#2a5ada',visible:true}
    ];

    const TIME_RANGES={
      '1d':{interval:'5m',limit:288},
      '3d':{interval:'15m',limit:288},
      '7d':{interval:'30m',limit:336},
      '1m':{interval:'2h',limit:360},
      '3m':{interval:'6h',limit:360}
    };

    const indicatorConfig={id:'HMA100',name:'',color:'rgba(226, 232, 240, 0.9)'};
    let indicatorVisible=true;

    function buildCompositeSeries(seriesList){
      const accum=new Map();
      seriesList.forEach(arr=>{
        if(!Array.isArray(arr)) return;
        arr.forEach(point=>{
          if(!point||!Number.isFinite(point.timestamp)||!Number.isFinite(point.price)) return;
          const key=point.timestamp;
          const next=accum.get(key)||{timestamp:key,sum:0,count:0};
          next.sum+=point.price;
          next.count+=1;
          accum.set(key,next);
        });
      });
      return Array.from(accum.values())
        .filter(entry=>entry.count>0)
        .map(entry=>({ timestamp:entry.timestamp, price:entry.sum/entry.count }))
        .sort((a,b)=>a.timestamp-b.timestamp);
    }

    function calculateHMA(series, period){
      if(!Array.isArray(series)||series.length<period) return [];
      const prices=series.map(p=>p.price);
      const timestamps=series.map(p=>p.timestamp);
      const halfPeriod=Math.max(1,Math.round(period/2));
      const sqrtPeriod=Math.max(1,Math.round(Math.sqrt(period)));
      const wma=(source, window)=>{
        const weightSum=window*(window+1)/2;
        return source.map((_,idx)=>{
          if(idx<window-1) return null;
          let weighted=0;
          for(let i=0;i<window;i++){
            const value=source[idx-window+1+i];
            if(!Number.isFinite(value)) return null;
            weighted+=value*(i+1);
          }
          return weighted/weightSum;
        });
      };

      const halfWma=wma(prices,halfPeriod);
      const fullWma=wma(prices,period);
      const diff=prices.map((_,idx)=>{
        const hw=halfWma[idx];
        const fw=fullWma[idx];
        if(hw==null||fw==null) return null;
        return (2*hw)-fw;
      });
      const hmaValues=wma(diff,sqrtPeriod);
      return hmaValues.reduce((acc,val,idx)=>{
        if(val==null) return acc;
        acc.push({ timestamp:timestamps[idx], price:val });
        return acc;
      },[]);
    }

    let activeRange='7d';
    let fetchToken=0;

     async function initCosmosChart(){
      chartCanvas=document.getElementById('cosmosChart');
      if(!chartCanvas) return;

      chartContext=chartCanvas.getContext('2d');
      resizeChart();
      createChartLegend();
      setupRangeControls();
    document.getElementById('marketCap').textContent='COSMOS Loading...';
      await fetchAllCosmosData();
      await fetchMarketCap();
      startChartAnimation();
      startRealTimeUpdates();
      
      window.addEventListener('resize',resizeChart);    
    }
    
    function resizeChart(){
      if(!chartCanvas) return;
      const rect=chartCanvas.parentElement.getBoundingClientRect();
      chartCanvas.width=rect.width-4; 
      chartCanvas.height=500;
      chartContext && drawChart();
    }
    
    function createChartLegend(){
      const legend=document.getElementById('chartLegend');
      legend.innerHTML='';

      cryptoConfig.forEach((c,idx)=>{
        const item=document.createElement('div');
        item.className='legend-item';
        item.innerHTML=`<div class="legend-color" style="background-color:${c.color}"></div><span>${c.name}</span>`;
        item.addEventListener('click',()=>{
          c.visible=!c.visible;
          item.style.opacity=c.visible?'1':'.35';
          drawChart()
        });
        legend.appendChild(item);
      });

      if(indicatorConfig.name){
        const indicatorItem=document.createElement('div');
        indicatorItem.className='legend-item legend-indicator';
        indicatorItem.innerHTML=`<div class="legend-color" style="background:linear-gradient(90deg, rgba(226,232,240,0.85), rgba(148,163,184,0.6)); border:1px solid rgba(148,163,184,0.4);"></div><span>${indicatorConfig.name}</span>`;
        indicatorItem.style.opacity=indicatorVisible?'1':'.35';
        indicatorItem.addEventListener('click',()=>{
          indicatorVisible=!indicatorVisible;
          indicatorItem.style.opacity=indicatorVisible?'1':'.35';
          drawChart();
        });
        legend.appendChild(indicatorItem);
      }
    }

    function setupRangeControls(){
      const container=document.getElementById('timeRange');
      if(!container) return;
      const buttons=Array.from(container.querySelectorAll('.chart-range-btn'));
      const syncActive=()=>{
        buttons.forEach(btn=>{
          const range=btn.dataset.range;
          btn.classList.toggle('active', range===activeRange);
        });
      };
      syncActive();
      buttons.forEach(btn=>{
        btn.addEventListener('click',()=>{
          const range=btn.dataset.range;
          if(!range||range===activeRange) return;
          activeRange=range;
          syncActive();
          fetchAllCosmosData();
        });
      });
    }

    async function fetchAllCosmosData(){
      const range=TIME_RANGES[activeRange]||TIME_RANGES['7d'];
      const {interval,limit}=range;
      const token=++fetchToken;
      const nextData=new Map();
      const tasks=cryptoConfig.map(async c=>{
        const symbol=`${c.id.toUpperCase()}USDT`;
        const endpoint=`/api/binance/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
        try{
          const res=await fetch(endpoint);
          if(!res.ok) throw new Error(`HTTP ${res.status}`);
          const rows=await res.json();
          const pts=Array.isArray(rows)
            ? rows.map(row=>({ timestamp:Number(row?.[0]), price:Number(row?.[4]) }))
                .filter(p=>Number.isFinite(p.timestamp)&&Number.isFinite(p.price))
            : [];
          pts.sort((a,b)=>a.timestamp-b.timestamp);
          nextData.set(c.id, pts);
        }catch(err){
          console.error('fetchAllCosmosData', symbol, err);
          nextData.set(c.id, []);
        }
      });
      try{
        await Promise.all(tasks);
      }catch(err){
        console.error('fetchAllCosmosData:pending', err);
      }
      if(token!==fetchToken) return;
      currentData=nextData;
      drawChart();
    }
    
    let raf=0;
    function startChartAnimation(){
      cancelAnimationFrame(raf);
      const loop=()=>{ 
        drawChart(); 
        raf=requestAnimationFrame(loop) 
      };
      loop();
    }
    
    function drawChart(){
      if(!chartContext||!chartCanvas) return;

      const ctx=chartContext, w=chartCanvas.width, h=chartCanvas.height;
      ctx.clearRect(0,0,w,h);

      const seriesEntries=cryptoConfig
        .map(cfg=>({ config:cfg, data:currentData.get(cfg.id) }))
        .filter(entry=>Array.isArray(entry.data)&&entry.data.length);
      const visibleEntries=seriesEntries.filter(entry=>entry.config.visible);

      let timeRange=null;
      if(visibleEntries.length){
        let minTs=Infinity, maxTs=-Infinity;
        visibleEntries.forEach(({data})=>{
          const first=data[0]?.timestamp;
          const last=data[data.length-1]?.timestamp;
          if(Number.isFinite(first) && first<minTs) minTs=first;
          if(Number.isFinite(last) && last>maxTs) maxTs=last;
        });
        if(Number.isFinite(minTs) && Number.isFinite(maxTs)){
          const span=Math.max(maxTs-minTs,1);
          timeRange={min:minTs,max:maxTs,span};
        }
      }

      const bg=ctx.createLinearGradient(0,0,0,h);
      bg.addColorStop(0,'rgba(139, 92, 246, 0.12)');
      bg.addColorStop(.5,'rgba(59, 130, 246, 0.06)');
      bg.addColorStop(1,'rgba(0, 0, 0, 0.4)');
      ctx.fillStyle=bg;
      ctx.fillRect(0,0,w,h);

      drawGrid(ctx,w,h,timeRange);

      visibleEntries.forEach(({config,data})=>{
        drawSeries(ctx,config,data,w,h,timeRange);
      });

      if(indicatorVisible && visibleEntries.length){
        const compositeSeries=buildCompositeSeries(visibleEntries.map(entry=>entry.data));
        const hmaSeries=calculateHMA(compositeSeries,100);
        drawIndicatorSeries(ctx,hmaSeries,compositeSeries,w,h,timeRange);
      }
    }

    function drawGrid(ctx,w,h,timeRange){
      const m={left:40,right:80,top:30,bottom:40};
      const cw=w-m.left-m.right, ch=h-m.top-m.bottom;

      ctx.strokeStyle='rgba(139, 92, 246, 0.18)';
      ctx.lineWidth=.5;
      
      // 세로선
      for(let i=0;i<=12;i++){ 
        const x=m.left+(i/12)*cw; 
        ctx.beginPath(); 
        ctx.moveTo(x,m.top); 
        ctx.lineTo(x,h-m.bottom); 
        ctx.stroke() 
      }
      
      // 가로선
      for(let i=0;i<=8;i++){ 
        const y=m.top+(i/8)*ch; 
        ctx.beginPath();
        ctx.moveTo(m.left,y);
        ctx.lineTo(w-m.right,y);
        ctx.stroke()
      }

      if(timeRange){
        const {min,span}=timeRange;
        const labelCount=6;
        ctx.fillStyle='rgba(226, 232, 240, 0.75)';
        ctx.font='11px Orbitron, monospace';
        ctx.textAlign='center';
        for(let i=0;i<=labelCount;i++){
          const ratio=i/labelCount;
          const x=m.left+ratio*cw;
          const ts=min+ratio*span;
          const label=formatDateLabel(ts,span);
          ctx.fillText(label,x,h-m.bottom+16);
        }
        ctx.textAlign='start';
      }
    }

    function formatDateLabel(ts,span){
      const d=new Date(ts);
      const mm=String(d.getMonth()+1).padStart(2,'0');
      const dd=String(d.getDate()).padStart(2,'0');
      const hh=String(d.getHours()).padStart(2,'0');
      const mi=String(d.getMinutes()).padStart(2,'0');
      const daySpan=span/(24*60*60*1000);
      if(daySpan>90){
        const yy=String(d.getFullYear()).slice(-2);
        return `${yy}/${mm}`;
      }
      if(daySpan>2) return `${mm}/${dd}`;
      return `${mm}/${dd} ${hh}:${mi}`;
    }

    function drawSeries(ctx,crypto,data,w,h,timeRange){
      const m={left:40,right:80,top:30,bottom:40};
      const cw=w-m.left-m.right, ch=h-m.top-m.bottom;
      if(!data.length) return;

      const prices=data.map(d=>d.price);
      const min=Math.min(...prices), max=Math.max(...prices), range=max-min||1;
      const baseTs=Number.isFinite(timeRange?.min)?timeRange.min:data[0].timestamp;
      const timeSpan=timeRange?.span ?? ((data[data.length-1].timestamp-data[0].timestamp)||1);
      const span=Math.max(timeSpan,1);
      const getX=ts=>m.left+((ts-baseTs)/span)*cw;

      ctx.save();
      ctx.strokeStyle=crypto.color;
      ctx.lineWidth=2.5;
      ctx.lineCap='round';
      ctx.lineJoin='round';
      ctx.shadowColor=crypto.color;
      ctx.shadowBlur=6;
      
      ctx.beginPath();
      data.forEach((p,i)=>{
        const x=getX(p.timestamp);
        const y=m.top+(ch-((p.price-min)/range)*ch);
        if(i===0) ctx.moveTo(x,y);
        else {
          const prev=data[i-1];
          const px=getX(prev.timestamp);
          const py=m.top+(ch-((prev.price-min)/range)*ch);
          const cx=(px+x)/2;
          ctx.quadraticCurveTo(cx,py,x,y);
        }
      });
      ctx.stroke();

      // 마지막 포인트
      const last=data[data.length-1];
      const lx=getX(last.timestamp);
      const ly=m.top+(ch-((last.price-min)/range)*ch);

      ctx.beginPath();
      ctx.arc(lx,ly,4,0,Math.PI*2);
      ctx.fillStyle=crypto.color;
      ctx.fill();

      ctx.fillStyle=crypto.color;
      ctx.font='11px Orbitron, monospace';
      ctx.textAlign='left';
      ctx.fillText(formatPrice(last.price), lx+8, ly+3);

      ctx.shadowBlur=0;
      ctx.restore();
    }

    function drawIndicatorSeries(ctx,series,baseSeries,w,h,timeRange){
      if(!Array.isArray(series)||series.length<2||!Array.isArray(baseSeries)||baseSeries.length<2) return;
      const m={left:40,right:80,top:30,bottom:40};
      const cw=w-m.left-m.right, ch=h-m.top-m.bottom;

      const combined=[...baseSeries,...series]
        .map(p=>p?.price)
        .filter(v=>Number.isFinite(v));
      if(!combined.length) return;

      const min=Math.min(...combined);
      const max=Math.max(...combined);
      const range=max-min||1;
      const baseTs=Number.isFinite(timeRange?.min)?timeRange.min:baseSeries[0].timestamp;
      const timeSpan=timeRange?.span ?? ((baseSeries[baseSeries.length-1].timestamp-baseSeries[0].timestamp)||1);
      const span=Math.max(timeSpan,1);
      const getX=ts=>m.left+((ts-baseTs)/span)*cw;

      ctx.save();
      ctx.strokeStyle=indicatorConfig.color;
      ctx.lineWidth=1.8;
      ctx.setLineDash([6,4]);
      ctx.lineCap='round';
      ctx.shadowColor='rgba(226, 232, 240, 0.35)';
      ctx.shadowBlur=8;

      ctx.beginPath();
      series.forEach((p,i)=>{
        const x=getX(p.timestamp);
        const y=m.top+(ch-((p.price-min)/range)*ch);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      });
      ctx.stroke();

      const last=series[series.length-1];
      const lx=getX(last.timestamp);
      const ly=m.top+(ch-((last.price-min)/range)*ch);

      ctx.setLineDash([]);
      ctx.shadowBlur=0;
      if(indicatorConfig.name){
        ctx.fillStyle=indicatorConfig.color;
        ctx.font='11px Orbitron, monospace';
        ctx.textAlign='left';
        ctx.fillText(indicatorConfig.name, lx+8, ly+3);
      }
      ctx.restore();
    }
    
    async function fetchMarketCap(){
      try{
        const res=await fetch('/api/global');
        const json=await res.json();
        const cap=json.data?.total_market_cap?.usd||0;
        document.getElementById('marketCap').textContent=`COSMOS Live: $${(cap/1e12).toFixed(2)}T`;
      }catch(err){
        console.error('fetchMarketCap',err);
      }
    }

    function startRealTimeUpdates(){
      const symbolMap=new Map(cryptoConfig.map(c=>[c.id.toUpperCase()+'USDT',c.id]));
      const applyPriceUpdates=updates=>{
        if(!Array.isArray(updates)) return;
        updates.forEach(item=>{
          if(!item) return;
          const symbol=(item.symbol||'').toUpperCase();
          const base=(item.base||'').toUpperCase();
          const targetId=base||symbolMap.get(symbol)||null;
          if(!targetId) return;
          const el=document.getElementById(`price-${targetId}`);
          if(!el) return;
          const price=Number(item.price);
          el.textContent=Number.isFinite(price)?formatPrice(price):'-';
        });
      };

      let pollingTimer=null;
      let pollingInFlight=false;
      const priceRefreshMs=Math.max(cryptoConfig.length*750,4000);

      const fetchAllPrices=async()=>{
        if(pollingInFlight) return;
        pollingInFlight=true;
        try{
          const tasks=cryptoConfig.map(c=>{
            const bnSym=`${c.id.toUpperCase()}USDT`;
            return fetch(`/api/binance/price?symbol=${bnSym}`)
              .then(res=>{ if(!res.ok) throw new Error(`HTTP ${res.status}`); return res.json(); })
              .then(data=>({
                symbol:(data.symbol||bnSym).toUpperCase(),
                base:(data.symbol||bnSym).replace(/USDT$/,'').toUpperCase(),
                price:Number(data.price)
              }))
              .catch(err=>{
                console.error('livePrice', bnSym, err);
                return { symbol:bnSym, base:bnSym.replace(/USDT$/,'').toUpperCase(), price:NaN };
              });
          });
          const results=await Promise.all(tasks);
          applyPriceUpdates(results);
        }finally{
          pollingInFlight=false;
        }
      };

      const startPolling=()=>{
        if(pollingTimer) clearInterval(pollingTimer);
        fetchAllPrices();
        pollingTimer=setInterval(fetchAllPrices,priceRefreshMs);
      };

      const startPriceStream=()=>{
        if(!('EventSource' in window)) return false;
        const symbols=Array.from(symbolMap.keys()).join(',');
        if(!symbols) return false;
        try{
          const es=new EventSource(`/api/binance/prices/stream?symbols=${symbols}&interval=${priceRefreshMs}`);
          es.addEventListener('message',evt=>{
            if(!evt.data) return;
            try{
              const payload=JSON.parse(evt.data);
              if(payload&&Array.isArray(payload.prices)) applyPriceUpdates(payload.prices);
            }catch(parseErr){
              console.error('price stream parse', parseErr);
            }
          });
          es.addEventListener('warn',evt=>{
            console.warn('price stream warning', evt.data);
          });
          es.addEventListener('error',()=>{
            if(es.readyState===EventSource.CLOSED){
              console.warn('price stream closed, falling back to polling');
              es.close();
              startPolling();
            }
          });
          return true;
        }catch(err){
          console.warn('price stream init failed', err);
          return false;
        }
      };

      setInterval(fetchMarketCap,60000);
      if(!startPriceStream()) startPolling();
    }

    // 초기화
    document.addEventListener('DOMContentLoaded',()=>{ 
      initClock();
      setTimeout(()=>{ 
        initCosmosChart() 
      },300) 
    });

    // 차트 컨트롤 이벤트
       document.getElementById('chartType')?.addEventListener('change',e=>{
      if(e.target.value==='single'){
        alert('Single Orbit 모드는 곧 출시됩니다!');
        e.target.value='multi'
      }
    });

    // Core architecture canvas animation
    (function initCoreArchitecture(){
      const section = document.getElementById('two4-core-architecture');
      const canvas = document.getElementById('core-architecture-canvas');
      if (!section || !canvas) return;

      const frame = section.querySelector('.core-architecture-frame');
      if (!frame) return;

      const ctx = canvas.getContext('2d');
      const nodes = {
        question: { x: 0.50, y: 0.10, label: '?', sublabel: 'Start', color: '#a855f7', shape: 'circle', tier: 'start' },
        ingress: { x: 0.15, y: 0.20, label: 'INGRESS', sublabel: 'Exchanges/AIs', color: '#ec4899', shape: 'triangle', tier: 'edge' },
        etl: { x: 0.15, y: 0.35, label: 'ETL', sublabel: 'Pipeline', color: '#ec4899', shape: 'triangle', tier: 'edge' },
        dataLake: { x: 0.32, y: 0.25, label: 'DATA LAKE', sublabel: 'Storage', color: '#3b82f6', shape: 'circle', tier: 'storage' },
        storage: { x: 0.15, y: 0.53, label: 'STORAGE', sublabel: 'Persistent', color: '#3b82f6', shape: 'circle', tier: 'storage' },
        gpuCluster1: { x: 0.15, y: 0.70, label: 'GPU', sublabel: 'Cluster A', color: '#3b82f6', shape: 'triangle', tier: 'compute' },
        cpuWorkers1: { x: 0.30, y: 0.70, label: 'CPU', sublabel: 'Workers A', color: '#ec4899', shape: 'triangle', tier: 'compute' },
        gpuCluster2: { x: 0.40, y: 0.82, label: 'GPU', sublabel: 'Cluster B', color: '#ec4899', shape: 'triangle', tier: 'compute' },
        cpuWorkers2: { x: 0.54, y: 0.82, label: 'CPU', sublabel: 'Workers B', color: '#9333ea', shape: 'triangle', tier: 'compute' },
        cache: { x: 0.68, y: 0.82, label: 'CACHE', sublabel: 'Memory', color: '#9333ea', shape: 'square', tier: 'compute' },
        queue1: { x: 0.15, y: 0.88, label: 'QUEUE', sublabel: 'Buffer A', color: '#3b82f6', shape: 'circle', tier: 'queue' },
        aiOrch1: { x: 0.58, y: 0.30, label: 'AI ORCHESTRATION', sublabel: 'Controller', color: '#14b8a6', shape: 'circle', tier: 'orchestration' },
        core: { x: 0.50, y: 0.50, label: 'TWO.4 CORE', sublabel: 'Central Hub', color: '#fb923c', shape: 'circle', tier: 'core' },
        aiOrch2: { x: 0.82, y: 0.20, label: 'AI ORCHESTRATION', sublabel: 'Manager', color: '#14b8a6', shape: 'square', tier: 'orchestration' },
        modelServing: { x: 0.82, y: 0.35, label: 'MODEL SERVING', sublabel: 'Inference', color: '#9333ea', shape: 'triangle', tier: 'ai' },
        strategyEngine: { x: 0.82, y: 0.50, label: 'STRATEGY', sublabel: 'Engine', color: '#9333ea', shape: 'triangle', tier: 'ai' },
        executionRouter: { x: 0.82, y: 0.65, label: 'EXECUTION', sublabel: 'Router', color: '#9333ea', shape: 'triangle', tier: 'execution' },
        queue2: { x: 0.74, y: 0.88, label: 'QUEUE', sublabel: 'Buffer B', color: '#9333ea', shape: 'circle', tier: 'queue' },
        notifications: { x: 0.88, y: 0.88, label: 'NOTIFY', sublabel: 'System', color: '#ec4899', shape: 'circle', tier: 'edge' }
      };

      const connections = [
        { from: 'question', to: 'core' },
        { from: 'ingress', to: 'dataLake' },
        { from: 'ingress', to: 'etl' },
        { from: 'etl', to: 'storage' },
        { from: 'dataLake', to: 'aiOrch1' },
        { from: 'dataLake', to: 'core' },
        { from: 'dataLake', to: 'storage' },
        { from: 'storage', to: 'core' },
        { from: 'storage', to: 'cpuWorkers1' },
        { from: 'gpuCluster1', to: 'queue1' },
        { from: 'cpuWorkers1', to: 'gpuCluster2' },
        { from: 'cpuWorkers1', to: 'core' },
        { from: 'gpuCluster2', to: 'core' },
        { from: 'cpuWorkers2', to: 'core' },
        { from: 'cache', to: 'core' },
        { from: 'aiOrch1', to: 'core' },
        { from: 'aiOrch1', to: 'modelServing' },
        { from: 'aiOrch2', to: 'modelServing' },
        { from: 'modelServing', to: 'strategyEngine' },
        { from: 'core', to: 'strategyEngine' },
        { from: 'strategyEngine', to: 'executionRouter' },
        { from: 'executionRouter', to: 'queue2' },
        { from: 'executionRouter', to: 'notifications' },
        { from: 'queue2', to: 'cache' }
      ];

      const activeConnections = new Set();
      const visibleConnections = new Set();
      let connectionIndex = 0;
      let width = 0;
      let height = 0;
      let dpr = window.devicePixelRatio || 1;
      let mouseX = 0;
      let mouseY = 0;
      let time = 0;

      function resize(){
        const rect = frame.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);
        mouseX = width / 2;
        mouseY = height / 2;
      }

      resize();
      window.addEventListener('resize', resize);

      function showNextConnection(){
        if (connectionIndex < connections.length){
          const conn = connections[connectionIndex];
          visibleConnections.add(`${conn.from}-${conn.to}`);
          connectionIndex += 1;
        }
      }

      showNextConnection();
      setInterval(showNextConnection, 2000);

      function activateRandomConnection(){
        const conn = connections[Math.floor(Math.random() * connections.length)];
        const key = `${conn.from}-${conn.to}`;
        activeConnections.add(key);
        setTimeout(() => activeConnections.delete(key), 800);
      }

      setInterval(activateRandomConnection, 150);

      frame.addEventListener('mousemove', (event) => {
        const rect = frame.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
      });

      frame.addEventListener('mouseleave', () => {
        mouseX = width / 2;
        mouseY = height / 2;
      });

      function drawTriangle(x, y, size){
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x - size * 0.866, y + size * 0.5);
        ctx.lineTo(x + size * 0.866, y + size * 0.5);
        ctx.closePath();
      }

      function drawSquare(x, y, size){
        ctx.beginPath();
        ctx.rect(x - size, y - size, size * 2, size * 2);
        ctx.closePath();
      }

      function animate(){
        time += 0.003;
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, width, height);

        connections.forEach(conn => {
          const from = nodes[conn.from];
          const to = nodes[conn.to];
          const key = `${conn.from}-${conn.to}`;
          if (!visibleConnections.has(key)) return;

          const isActive = activeConnections.has(key);
          const fromX = from.x * width;
          const fromY = from.y * height;
          const toX = to.x * width;
          const toY = to.y * height;
          const fromSize = from.tier === 'core' ? 34 : from.tier === 'start' ? 18 : 24;
          const toSize = to.tier === 'core' ? 34 : to.tier === 'start' ? 18 : 24;
          const angle = Math.atan2(toY - fromY, toX - fromX);
          const margin = 8;
          const startX = fromX + Math.cos(angle) * (fromSize + margin);
          const startY = fromY + Math.sin(angle) * (fromSize + margin);
          const endX = toX - Math.cos(angle) * (toSize + margin);
          const endY = toY - Math.sin(angle) * (toSize + margin);
          const dx = Math.abs(endX - startX);
          const dy = Math.abs(endY - startY);

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          if (dx > dy){
            const midX = startX + (endX - startX) * 0.5;
            ctx.lineTo(midX, startY);
            ctx.lineTo(midX, endY);
            ctx.lineTo(endX, endY);
          } else {
            const midY = startY + (endY - startY) * 0.5;
            ctx.lineTo(startX, midY);
            ctx.lineTo(endX, midY);
            ctx.lineTo(endX, endY);
          }

          if (isActive){
            ctx.strokeStyle = from.color;
            ctx.lineWidth = 0.6;
            ctx.shadowColor = from.color;
            ctx.shadowBlur = 14;
            ctx.stroke();
            ctx.shadowBlur = 0;
          } else {
            ctx.strokeStyle = `${from.color}40`;
            ctx.lineWidth = 0.5;
            ctx.shadowColor = from.color;
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        });

        Object.entries(nodes).forEach(([key, node]) => {
          const x = node.x * width;
          const y = node.y * height;
          const dx = mouseX - x;
          const dy = mouseY - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const isNear = distance < 130;
          const nodeSize = node.tier === 'core' ? 34 : node.tier === 'start' ? 18 : 24;

          if (node.tier === 'core'){
            const bgGradient = ctx.createRadialGradient(x, y, 0, x, y, nodeSize * 3);
            bgGradient.addColorStop(0, 'rgba(251, 146, 60, 0.18)');
            bgGradient.addColorStop(0.5, 'rgba(251, 146, 60, 0.08)');
            bgGradient.addColorStop(1, 'rgba(251, 146, 60, 0)');
            ctx.fillStyle = bgGradient;
            ctx.beginPath();
            ctx.arc(x, y, nodeSize * 3, 0, Math.PI * 2);
            ctx.fill();

            for (let i = 0; i < 3; i += 1){
              const pulseRadius = 42 + i * 14 + Math.sin(time * 2 + i * 0.5) * 4;
              ctx.beginPath();
              ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
              ctx.strokeStyle = `${node.color}${(40 - i * 8).toString(16).padStart(2, '0')}`;
              ctx.lineWidth = 1.3;
              ctx.shadowColor = node.color;
              ctx.shadowBlur = 8;
              ctx.stroke();
              ctx.shadowBlur = 0;
            }

            const rotationSpeed = time * 0.5;
            for (let i = 0; i < 6; i += 1){
              const angle = (Math.PI * 2 / 6) * i + rotationSpeed;
              const innerR = 46;
              const outerR = 52;
              ctx.beginPath();
              ctx.moveTo(x + Math.cos(angle) * innerR, y + Math.sin(angle) * innerR);
              ctx.lineTo(x + Math.cos(angle) * outerR, y + Math.sin(angle) * outerR);
              ctx.strokeStyle = `${node.color}60`;
              ctx.lineWidth = 1.8;
              ctx.shadowColor = node.color;
              ctx.shadowBlur = 6;
              ctx.stroke();
              ctx.shadowBlur = 0;
            }
          }

          if (node.shape === 'circle'){
            ctx.beginPath();
            ctx.arc(x, y, nodeSize, 0, Math.PI * 2);
            if (node.tier === 'core'){
              const innerGradient = ctx.createRadialGradient(x, y, 0, x, y, nodeSize);
              innerGradient.addColorStop(0, 'rgba(251, 191, 36, 0.32)');
              innerGradient.addColorStop(0.5, 'rgba(251, 146, 60, 0.18)');
              innerGradient.addColorStop(1, 'rgba(10, 10, 15, 0.9)');
              ctx.fillStyle = innerGradient;
              ctx.fill();
              ctx.strokeStyle = node.color;
              ctx.lineWidth = 2.2;
              ctx.shadowColor = node.color;
              ctx.shadowBlur = 16;
              ctx.stroke();
              ctx.shadowBlur = 0;
            } else if (node.tier === 'start'){
              const questionGradient = ctx.createRadialGradient(x, y, 0, x, y, nodeSize);
              questionGradient.addColorStop(0, 'rgba(168, 85, 247, 0.28)');
              questionGradient.addColorStop(0.5, 'rgba(168, 85, 247, 0.12)');
              questionGradient.addColorStop(1, 'rgba(10, 10, 15, 0.92)');
              ctx.fillStyle = questionGradient;
              ctx.fill();
              ctx.strokeStyle = node.color;
              ctx.lineWidth = 1.8;
              ctx.shadowColor = node.color;
              ctx.shadowBlur = 12;
              ctx.stroke();
              ctx.shadowBlur = 0;
            } else {
              ctx.strokeStyle = node.color;
              ctx.lineWidth = isNear ? 1.8 : 1;
              ctx.stroke();
              ctx.fillStyle = '#0a0a0f';
              ctx.fill();
            }
          } else if (node.shape === 'triangle'){
            drawTriangle(x, y, nodeSize);
            ctx.strokeStyle = node.color;
            ctx.lineWidth = isNear ? 1.8 : 1;
            ctx.stroke();
            ctx.fillStyle = '#0a0a0f';
            ctx.fill();
          } else if (node.shape === 'square'){
            drawSquare(x, y, nodeSize);
            ctx.strokeStyle = node.color;
            ctx.lineWidth = isNear ? 1.8 : 1;
            ctx.stroke();
            ctx.fillStyle = '#0a0a0f';
            ctx.fill();
          }

          if (node.tier !== 'start' && node.tier !== 'core'){
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fillStyle = node.color;
            ctx.shadowColor = node.color;
            ctx.shadowBlur = isNear ? 10 : 5;
            ctx.fill();
            ctx.shadowBlur = 0;
          }

          if (isNear || node.tier === 'core' || node.tier === 'start'){
            if (node.tier === 'start'){
              ctx.fillStyle = '#ffffff';
              ctx.font = 'bold 26px Rajdhani, sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(node.label, x, y);
            } else if (node.tier === 'core'){
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.font = 'bold 18px Rajdhani, sans-serif';
              const gradient1 = ctx.createLinearGradient(x - 30, y - 10, x + 30, y - 10);
              gradient1.addColorStop(0, '#fbbf24');
              gradient1.addColorStop(1, '#fb923c');
              ctx.fillStyle = gradient1;
              ctx.shadowColor = '#fb923c';
              ctx.shadowBlur = 12;
              ctx.fillText('TWO.4', x, y - 8);
              ctx.shadowBlur = 0;
              ctx.font = 'bold 15px Rajdhani, sans-serif';
              const gradient2 = ctx.createLinearGradient(x - 25, y + 8, x + 25, y + 8);
              gradient2.addColorStop(0, '#fb923c');
              gradient2.addColorStop(1, '#f97316');
              ctx.fillStyle = gradient2;
              ctx.shadowColor = '#fb923c';
              ctx.shadowBlur = 12;
              ctx.fillText('CORE', x, y + 8);
              ctx.shadowBlur = 0;
            } else {
              ctx.fillStyle = '#e0e0e0';
              ctx.font = '600 11px Rajdhani, sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(node.label, x, y - nodeSize - 12);
              ctx.fillStyle = '#666666';
              ctx.font = '400 9px Rajdhani, sans-serif';
              ctx.fillText(node.sublabel, x, y - nodeSize - 2);
            }
          }
        });

        requestAnimationFrame(animate);
      }

      animate();
    })();

    // Seed AI click event
    document.addEventListener('DOMContentLoaded', function() {
      const seedContainer = document.getElementById('seed-container');

      if (seedContainer) {
        seedContainer.addEventListener('click', function() {
         window.location.href = 'https://two4-production.up.railway.app/ai/seed.html';
        });

        seedContainer.style.cursor = 'pointer';

        seedContainer.addEventListener('mouseenter', function() {
          seedContainer.style.transform = 'scale(1.05)';
          seedContainer.style.transition = 'transform 0.2s ease';
        });

        seedContainer.addEventListener('mouseleave', function() {
          seedContainer.style.transform = 'scale(1.0)';
        });
      }
    });
  </script>
</body>
</html>
