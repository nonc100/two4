<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>COSMOS • Chart</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root{
    --bg:#0b1018; --panel:#111827; --text:#e8eefc; --muted:#9aa3b6;
    --up:#22c55e; --down:#ef4444; --chip:#1f2937; --chip-on:#39445a;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(1200px 600px at 50% 0%, #182036 0%, var(--bg) 60%); color:var(--text); font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:1100px;margin:0 auto;padding:10px 12px 24px}
  .toolbar{position:sticky;top:0;z-index:5;backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px); background:rgba(12,16,24,.55); border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .sym{font-weight:800; letter-spacing:.04em; opacity:.9}
  .chips{display:flex; gap:6px; flex-wrap:wrap; align-items:center}
  .chip{background:var(--chip); color:#dbeafe; border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:6px 10px; font-weight:700; cursor:pointer; user-select:none}
  .chip.on{background:var(--chip-on); border-color:rgba(114,153,255,.36)}
  .chip.ghost{background:transparent; border-color:rgba(255,255,255,.14)}
  .grow{flex:1}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .right{margin-left:auto; display:flex; gap:6px}
  .panel{margin-top:10px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:hidden}
  #chart{height:66vh; min-height:420px}
  @media (max-width:767px){
    .toolbar{padding:6px 8px}
    #chart{height:73vh; min-height:420px}
    .sym{display:none} /* 상단 공간 최소화 */
  }
  .badge{display:inline-flex; gap:6px; align-items:center; padding:3px 8px; border-radius:999px; font-weight:800; font-size:12px; border:1px solid rgba(255,255,255,.14); opacity:.9}
  .hint{color:var(--muted); font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <!-- 초슬림 상단 컨트롤 -->
  <div class="toolbar">
    <div class="sym" id="symLabel">BTCUSDT</div>
    <div class="chips" id="tfChips">
      <div class="chip on" data-tf="15m">15m</div>
      <div class="chip" data-tf="1h">1h</div>
      <div class="chip" data-tf="4h">4h</div>
      <div class="chip" data-tf="1d">1d</div>
    </div>
    <div class="chips">
      <div class="chip" id="togRSI">RSI</div>
      <div class="chip on" id="togOI">OI</div>
      <div class="chip" id="togH50">HMA50</div>
      <div class="chip" id="togH100">HMA100</div>
      <div class="chip" id="togH200">HMA200</div>
    </div>
    <div class="right">
      <div class="chip ghost" id="btnFit">Fit</div>
      <div class="chip ghost" id="btnReset">Reset</div>
      <a class="chip" id="btnBinance" target="_blank" rel="noopener">열기</a>
    </div>
  </div>

  <!-- 차트 영역 -->
  <div class="panel">
    <div id="chart"></div>
  </div>

  <p class="hint">팁: 핀치/휠로 확대, 드래그로 이동. 칩을 눌러 RSI/OI/HMA를 켜고 끌 수 있어요.</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<script>
/* ====== Params ====== */
const qs=new URLSearchParams(location.search);
const SYMBOL=(qs.get('sym')||qs.get('symbol')||'BTCUSDT').toUpperCase();
let TF=(qs.get('tf')||qs.get('interval')||'15m').toLowerCase();

/* ====== Fetch helpers (direct → proxy) ====== */
async function getJson(direct, proxy){
  try{ const r=await fetch(direct); if(!r.ok) throw 0; return await r.json(); }
  catch{ const r2=await fetch(proxy); if(!r2.ok) throw new Error('fetch failed'); return await r2.json(); }
}
function klineURL(sym,tf,limit=800){
  const q=`symbol=${sym}&interval=${tf}&limit=${limit}`;
  return [
    `https://api.binance.com/api/v3/klines?${q}`,
    `/api/binance/klines?${q}`
  ];
}
function oiURL(sym,period='5m',limit=500){
  const q=`symbol=${sym}&period=${period}&limit=${limit}`;
  return [
    `https://fapi.binance.com/futures/data/openInterestHist?${q}`,
    `/api/binance/openInterestHist?${q}`
  ];
}

/* ====== Math: WMA & HMA ====== */
function wma(values, period){
  const out=[]; const w=period*(period+1)/2;
  for(let i=0;i<values.length;i++){
    if(i<period-1){ out.push(null); continue; }
    let sum=0, weight=period;
    for(let k=0;k<period;k++) sum += values[i-k]*weight-- ;
    out.push(sum/w);
  }
  return out;
}
function hma(values, period){
  const half=Math.floor(period/2);
  const sqrt=Math.max(2, Math.floor(Math.sqrt(period)));
  const wmaHalf = wma(values, half);
  const wmaFull = wma(values, period);
  const diff = values.map((_,i)=>{
    const a=wmaHalf[i]??null, b=wmaFull[i]??null;
    return (a==null || b==null)?null:(2*a - b);
  });
  return wma(diff, sqrt);
}

/* ====== Build chart ====== */
const root = document.getElementById('chart');
const chart = LightweightCharts.createChart(root,{
  layout:{ background:{ type: 'solid', color:'transparent'}, textColor:'#dfe8ff' },
  grid:{ vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
  rightPriceScale:{ borderVisible:false, scaleMargins:{top:0.12,bottom:0.18}},
  timeScale:{ borderVisible:false, rightOffset:6, timeVisible:true, fixLeftEdge:false, fixRightEdge:false },
  crosshair:{ mode: LightweightCharts.CrosshairMode.Normal, vertLine:{color:'rgba(255,255,255,.25)'}, horzLine:{color:'rgba(255,255,255,.25)'} }
});
const mainSeries = chart.addCandlestickSeries({
  upColor:'#22c55e', downColor:'#ef4444', borderVisible:false, wickUpColor:'#22c55e', wickDownColor:'#ef4444',
  lastValueVisible:true, priceLineVisible:true, priceLineColor:'#6aa3ff'
});
const volSeries = chart.addHistogramSeries({ priceScaleId: '', priceFormat:{ type:'volume' }, color:'#8aa0c6', priceLineVisible:false, lastValueVisible:false, overlay:true, base:0, scaleMargins:{ top:0.8, bottom:0 }});

/* Indicator panes (RSI & OI) */
const rsiPane = chart.addLineSeries({ color:'#7aa5ff', lineWidth:2, priceScaleId:'rsi', lastValueVisible:false });
chart.priceScale('rsi').applyOptions({ scaleMargins:{ top:0.72, bottom:0.12 }, borderVisible:false });
const oiPane = chart.addLineSeries({ color:'#b397ff', lineWidth:2, priceScaleId:'oi', lastValueVisible:false });
chart.priceScale('oi').applyOptions({ scaleMargins:{ top:0.86, bottom:0.02 }, borderVisible:false });

/* HMA overlays */
const h50 = chart.addLineSeries({ color:'#18ffd0', lineWidth:2, lastValueVisible:false });
const h100= chart.addLineSeries({ color:'#f5e663', lineWidth:2, lastValueVisible:false });
const h200= chart.addLineSeries({ color:'#ff9b5e', lineWidth:2, lastValueVisible:false });

/* UI labels */
document.getElementById('symLabel').textContent = SYMBOL;
document.getElementById('btnBinance').href = `https://www.binance.com/ko/trade/${SYMBOL}`;

/* TF chips */
const tfChips = Array.from(document.querySelectorAll('#tfChips .chip'));
function syncTFUI(){
  tfChips.forEach(c=>c.classList.toggle('on', c.dataset.tf===TF));
}
tfChips.forEach(c=>c.onclick=()=>{ TF=c.dataset.tf; syncTFUI(); loadAll(); });

/* Toggles */
const togRSI  = document.getElementById('togRSI');
const togOI   = document.getElementById('togOI');
const togH50  = document.getElementById('togH50');
const togH100 = document.getElementById('togH100');
const togH200 = document.getElementById('togH200');

let showRSI=false, showOI=true, showH50=false, showH100=false, showH200=false;
function syncToggles(){
  togRSI.classList.toggle('on',showRSI);
  togOI.classList.toggle('on',showOI);
  togH50.classList.toggle('on',showH50);
  togH100.classList.toggle('on',showH100);
  togH200.classList.toggle('on',showH200);
  rsiPane.applyOptions({visible:showRSI});
  oiPane.applyOptions({visible:showOI});
  h50.applyOptions({visible:showH50});
  h100.applyOptions({visible:showH100});
  h200.applyOptions({visible:showH200});
}
[togRSI,togOI,togH50,togH100,togH200].forEach(btn=>{
  btn.onclick=()=>{ 
    if(btn===togRSI) showRSI=!showRSI;
    if(btn===togOI) showOI=!showOI;
    if(btn===togH50) showH50=!showH50;
    if(btn===togH100) showH100=!showH100;
    if(btn===togH200) showH200=!showH200;
    syncToggles();
  };
});

/* Fit / Reset */
document.getElementById('btnFit').onclick = ()=> chart.timeScale().fitContent();
document.getElementById('btnReset').onclick = ()=> { chart.timeScale().setVisibleRange({from:undefined,to:undefined}); chart.timeScale().fitContent(); };

/* Data caches */
let klines = []; // [time,open,high,low,close,volume]
let rsiLen = 14; // 고정(설정 UI 제거)
let oiPeriod = '5m'; // 모바일에서 심플하게 유지(필요시 URL tf에 맞춰 자동화 가능)

/* Converters */
function toCandle(k){ return { time: Math.floor(k[0]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4] }; }
function toVolume(k){ return { time: Math.floor(k[0]/1000), value:+k[5], color: (+k[4] >= +k[1]) ? 'rgba(34,197,94,.55)' : 'rgba(239,68,68,.55)' }; }

/* RSI calc (close only) */
function calcRSI(close, length=14){
  const out=[];
  let avgGain=0, avgLoss=0;
  for(let i=1;i<close.length;i++){
    const ch=close[i]-close[i-1];
    const gain=Math.max(ch,0), loss=Math.max(-ch,0);
    if(i<=length){ avgGain+=gain; avgLoss+=loss; if(i===length){ avgGain/=length; avgLoss/=length; const rs=avgLoss===0?100:avgGain/avgLoss; out.push({time:klines[i][0]/1000, value: 100-(100/(1+rs))}); } }
    else{
      avgGain=(avgGain*(length-1)+gain)/length;
      avgLoss=(avgLoss*(length-1)+loss)/length;
      const rs=avgLoss===0?100:avgGain/avgLoss;
      out.push({time:klines[i][0]/1000, value: 100-(100/(1+rs))});
    }
  }
  return out;
}

/* Loader */
async function loadAll(){
  syncTFUI();
  const [dURL,pURL] = klineURL(SYMBOL, TF);
  const rows = await getJson(dURL,pURL);
  klines = rows;
  const candles = rows.map(toCandle);
  const volumes = rows.map(toVolume);
  mainSeries.setData(candles);
  volSeries.setData(volumes);

  // HMA overlays
  const closes = rows.map(r => +r[4]);
  const h50v  = hma(closes, 50).map((v,i)=>v==null?null:{time:rows[i][0]/1000, value:v}).filter(Boolean);
  const h100v = hma(closes,100).map((v,i)=>v==null?null:{time:rows[i][0]/1000, value:v}).filter(Boolean);
  const h200v = hma(closes,200).map((v,i)=>v==null?null:{time:rows[i][0]/1000, value:v}).filter(Boolean);
  h50.setData(h50v); h100.setData(h100v); h200.setData(h200v);

  // RSI
  const rsiData = calcRSI(closes, rsiLen);
  rsiPane.setData(rsiData);

  // OI
  try{
    const [od,op] = oiURL(SYMBOL, oiPeriod, 500);
    const oij = await getJson(od,op);
    const oiData = oij.map(x=>({ time: Math.floor(new Date(x.timestamp).getTime()/1000), value: +x.sumOpenInterest })); 
    oiPane.setData(oiData);
  }catch(e){ oiPane.setData([]); }

  chart.timeScale().fitContent();
}
syncToggles();
loadAll();

/* mobile price label 가시성 유지(차트 기본 옵션으로 충분하지만 보강) */
mainSeries.applyOptions({ lastValueVisible:true, priceLineVisible:true, priceLineColor:'#6aa3ff' });

</script>
</body>
</html>
