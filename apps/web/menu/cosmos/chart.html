<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>COSMOS • Chart</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root{
    --bg:#0b1018; --panel:#0e1421; --text:#e8eefc; --muted:#9aa3b6;
    --up:#22c55e; --down:#ef4444; --chip:#1b2334; --chip-on:#2a3650;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(1200px 600px at 50% 0%, #182036 0%, var(--bg) 60%); color:var(--text); font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{height:100svh; display:flex; flex-direction:column}

  /* 상단: 심볼/가격 스트립 */
  .ticker{display:flex; align-items:center; gap:10px; padding:10px 12px; background:rgba(12,16,24,.55);
    border-bottom:1px solid rgba(255,255,255,.06); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px)}
  .sym{font-weight:900; letter-spacing:.04em; font-size:15px}
  .price{font-weight:900; font-variant-numeric:tabular-nums}
  .chg{font-weight:800; font-size:12px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.10)}
  .up{color:var(--up); background:rgba(34,197,94,.08)}
  .down{color:var(--down); background:rgba(239,68,68,.08)}
  .muted{color:var(--muted)}
  .spacer{flex:1}

  /* 타임프레임 바 */
  .tfbar{display:flex; gap:6px; padding:8px 12px; overflow-x:auto; border-bottom:1px solid rgba(255,255,255,.06); background:rgba(12,16,24,.35)}
  .chip{flex:0 0 auto; background:var(--chip); color:#dbeafe; border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:6px 10px; font-weight:700; cursor:pointer; user-select:none}
  .chip.on{background:var(--chip-on); border-color:rgba(114,153,255,.36)}
  .ghost{background:transparent; border-color:rgba(255,255,255,.14)}

  /* 차트 */
  #chart{flex:1; min-height:360px}

  /* 하단 도크 */
  .dock{display:flex; gap:8px; align-items:center; justify-content:space-between; padding:8px 12px;
    background:rgba(12,16,24,.55); border-top:1px solid rgba(255,255,255,.06); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px)}
  .dock .group{display:flex; gap:6px; flex-wrap:wrap}

  @media (min-width:1024px){
    .ticker{padding:12px 18px}
    .tfbar{padding:10px 18px}
    .dock{padding:10px 18px}
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- 상단 심볼/가격 스트립 -->
  <div class="ticker">
    <div class="sym" id="symLabel">BTCUSDT</div>
    <div class="price" id="lastPrice">-</div>
    <div class="chg muted" id="pctChg">0.00%</div>
    <div class="spacer"></div>
  </div>

  <!-- 타임프레임 바 -->
  <div class="tfbar" id="tfBar">
    <div class="chip" data-tf="1m">1m</div>
    <div class="chip" data-tf="5m">5m</div>
    <div class="chip on" data-tf="15m">15m</div>
    <div class="chip" data-tf="30m">30m</div>
    <div class="chip" data-tf="1h">1h</div>
    <div class="chip" data-tf="4h">4h</div>
    <div class="chip" data-tf="1d">1d</div>
    <div class="chip" data-tf="1w">1w</div>
  </div>

  <!-- 차트 -->
  <div id="chart"></div>

  <!-- 하단 도크 -->
  <div class="dock">
    <div class="group">
      <div class="chip" id="togRSI">RSI</div>
      <div class="chip on" id="togOI">OI</div>
      <div class="chip" id="togHMA">HMA</div>
      <div class="chip" id="togBB">BB</div>
    </div>
    <div class="group">
      <div class="chip ghost" id="btnFit">Fit</div>
      <div class="chip ghost" id="btnReset">Reset</div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<script>
/* ===== 파라미터 ===== */
const qs=new URLSearchParams(location.search);
const idMap={bitcoin:'BTCUSDT',ethereum:'ETHUSDT',ripple:'XRPUSDT'};
let s=qs.get('sym')||qs.get('symbol');
if(!s){
  const id=qs.get('id');
  if(id) s=idMap[id.toLowerCase()]||id;
}
const SYMBOL=(s||'BTCUSDT').toUpperCase();
let TF=(qs.get('tf')||qs.get('interval')||'15m').toLowerCase();

/* ===== Fetch 도우미 (직접 → 프록시) ===== */
async function getJson(direct, proxy){
  try{ const r=await fetch(direct); if(!r.ok) throw 0; return await r.json(); }
  catch{ const r2=await fetch(proxy); if(!r2.ok) throw new Error('fetch failed'); return await r2.json(); }
}
function tfLimit(tf){
  if (tf.endsWith('m')) return 1200;     // 1m/5m/15m/30m
  if (tf==='1h' || tf==='4h') return 1500;
  if (tf==='1d' || tf==='1w') return 1000;
  return 1000;
}
function klineURL(sym,tf,limit){
  limit = limit ?? tfLimit(tf);
  const q=`symbol=${sym}&interval=${tf}&limit=${limit}`;
  return [
    `https://api.binance.com/api/v3/klines?${q}`,
    `/api/binance/klines?${q}`
  ];
}
function oiURL(sym,period='5m',limit=600){
  const q=`symbol=${sym}&period=${period}&limit=${limit}`;
  return [
    `https://fapi.binance.com/futures/data/openInterestHist?${q}`,
    `/api/binance/openInterestHist?${q}`
  ];
}

/* ===== 수학: WMA/HMA & SMA/STD & BB & RSI ===== */
function wma(values, period){
  const out=[]; const w=period*(period+1)/2;
  for(let i=0;i<values.length;i++){
    if(i<period-1){ out.push(null); continue; }
    let sum=0, weight=period;
    for(let k=0;k<period;k++) sum += values[i-k]*weight-- ;
    out.push(sum/w);
  }
  return out;
}
function hma(values, period){
  const half=Math.floor(period/2), sqrt=Math.max(2, Math.floor(Math.sqrt(period)));
  const wmaHalf = wma(values, half);
  const wmaFull = wma(values, period);
  const diff = values.map((_,i)=>{
    const a=wmaHalf[i]??null, b=wmaFull[i]??null;
    return (a==null || b==null)?null:(2*a - b);
  });
  return wma(diff, sqrt);
}
function sma(values, period){
  const out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=period) sum -= values[i-period];
    out.push(i>=period-1 ? sum/period : null);
  }
  return out;
}
function std(values, period){
  const out=[]; let sum=0, sumsq=0;
  for(let i=0;i<values.length;i++){
    const v=values[i]; sum += v; sumsq += v*v;
    if(i>=period){ const old=values[i-period]; sum -= old; sumsq -= old*old; }
    if(i>=period-1){
      const mean = sum/period;
      out.push(Math.sqrt(Math.max(0, (sumsq/period) - mean*mean )));
    }else out.push(null);
  }
  return out;
}
function calcBB(close, period=20, mult=2){
  const m = sma(close, period);
  const s = std(close, period);
  const upper=[], lower=[];
  for(let i=0;i<close.length;i++){
    const mi=m[i], si=s[i];
    upper.push(mi==null?null:mi+mult*si);
    lower.push(mi==null?null:mi-mult*si);
  }
  return {mid:m, upper, lower};
}

/* ===== 차트 생성 ===== */
const root = document.getElementById('chart');
const chart = LightweightCharts.createChart(root,{
  layout:{ background:{ type:'solid', color:'transparent' }, textColor:'#dfe8ff' },
  grid:{ vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
  rightPriceScale:{ borderVisible:false, scaleMargins:{ top:0.10, bottom:0.22 } },
timeScale:{ borderVisible:false, rightOffset:8, timeVisible:true, timezone:'Asia/Seoul' },
  crosshair:{ mode:LightweightCharts.CrosshairMode.Normal, vertLine:{color:'rgba(255,255,255,.25)'}, horzLine:{color:'rgba(255,255,255,.25)'} },
  watermark:{ visible:true, text:'TWO.4', fontSize:22, color:'rgba(255,255,255,.14)', horzAlign:'right', vertAlign:'top' }
});
const mainSeries = chart.addCandlestickSeries({
  upColor:'#22c55e', downColor:'#ef4444', borderVisible:false, wickUpColor:'#22c55e', wickDownColor:'#ef4444',
  lastValueVisible:true, priceLineVisible:true, priceLineColor:'#6aa3ff'
});

/* 더 작은 볼륨(칸식) */
const volSeries = chart.addHistogramSeries({
  priceScaleId:'', priceFormat:{type:'volume'}, color:'rgba(180,200,255,.35)',
  priceLineVisible:false, lastValueVisible:false, overlay:true, base:0
});
chart.priceScale('').applyOptions({ scaleMargins:{ top:0.93, bottom:0 }});

/* 보조지표 패널 */
const rsiPane = chart.addLineSeries({ 
  color:'#7aa5ff', lineWidth:2, priceScaleId:'rsi', 
  lastValueVisible:false, priceLineVisible:false 
});
chart.priceScale('rsi').applyOptions({ scaleMargins:{ top:0.70, bottom:0.12 }, borderVisible:false });

const oiPane = chart.addLineSeries({ 
  color:'#b397ff', lineWidth:2, priceScaleId:'oi', 
  lastValueVisible:false, priceLineVisible:false 
});
chart.priceScale('oi').applyOptions({ scaleMargins:{ top:0.86, bottom:0.02 }, borderVisible:false });

/* HMA 3종 (동시 토글, 굵기 1) */
const h50  = chart.addLineSeries({ color:'#ff4d4d', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const h100 = chart.addLineSeries({ color:'#ffd24d', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const h200 = chart.addLineSeries({ color:'#7dd3fc', lineWidth:1, lastValueVisible:false, priceLineVisible:false });

/* 볼린저밴드 3선 */
const bbUpper = chart.addLineSeries({ color:'rgba(122,165,255,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const bbMid   = chart.addLineSeries({ color:'rgba(200,210,230,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const bbLower = chart.addLineSeries({ color:'rgba(122,165,255,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });

/* UI 세팅 */
document.getElementById('symLabel').textContent = SYMBOL;

/* TF 바 동작 */
const tfChips = Array.from(document.querySelectorAll('#tfBar .chip'));
function syncTFUI(){ tfChips.forEach(c=>c.classList.toggle('on', c.dataset.tf===TF)); }
tfChips.forEach(c=>c.onclick=()=>{ TF=c.dataset.tf; syncTFUI(); loadAll(); });

/* 토글 */
const togRSI  = document.getElementById('togRSI');
const togOI   = document.getElementById('togOI');
const togHMA  = document.getElementById('togHMA');
const togBB   = document.getElementById('togBB');

let showRSI=false, showOI=true, showHMA=false, showBB=false;
function syncToggles(){
  togRSI.classList.toggle('on',showRSI);
  togOI.classList.toggle('on',showOI);
  togHMA.classList.toggle('on',showHMA);
  togBB.classList.toggle('on',showBB);
  rsiPane.applyOptions({visible:showRSI});
  oiPane.applyOptions({visible:showOI});
  h50.applyOptions({visible:showHMA});
  h100.applyOptions({visible:showHMA});
  h200.applyOptions({visible:showHMA});
  bbUpper.applyOptions({visible:showBB});
  bbMid.applyOptions({visible:showBB});
  bbLower.applyOptions({visible:showBB});
}
[togRSI,togOI,togHMA,togBB].forEach(btn=>{
  btn.onclick=()=>{ 
    if(btn===togRSI) showRSI=!showRSI;
    if(btn===togOI) showOI=!showOI;
    if(btn===togHMA) showHMA=!showHMA;
    if(btn===togBB)  showBB=!showBB;
    syncToggles();
  };
});

/* Fit / Reset */
document.getElementById('btnFit').onclick = ()=> chart.timeScale().fitContent();
document.getElementById('btnReset').onclick = ()=> { chart.timeScale().setVisibleRange({from:undefined,to:undefined}); chart.timeScale().fitContent(); };

/* 데이터 컨테이너 */
let rtime=[], klines=[];

/* 변환기 */
function normTs(t){ return t > 1e12 ? Math.floor(t/1000) : t; }
const toCandle = k => ({ time: normTs(k[0]), open:+k[1], high:+k[2], low:+k[3], close:+k[4] });
const toVolume = k => ({ time: normTs(k[0]), value:+k[5], color:(+k[4] >= +k[1]) ? 'rgba(34,197,94,.55)' : 'rgba(239,68,68,.55)' });

/* 로더 */
async function loadAll(){
  syncTFUI();
  const [dURL,pURL] = klineURL(SYMBOL, TF);
  const rows = await getJson(dURL,pURL);
  klines = rows;
  rtime = rows.map(r=>normTs(r[0]));

  const candles = rows.map(toCandle);
  const volumes = rows.map(toVolume);
  mainSeries.setData(candles);
  volSeries.setData(volumes);

  // 가격/등락 표시
  const last = rows.at(-1), prev = rows.at(-2) || last;
  const lastPrice = +last[4], prevClose = +prev[4];
  const pct = ((lastPrice - prevClose)/prevClose)*100;
  document.getElementById('lastPrice').textContent = lastPrice.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  const chg = document.getElementById('pctChg');
  chg.textContent = (pct>=0?'+':'') + pct.toFixed(2) + '%';
  chg.className = 'chg ' + (pct>=0?'up':'down');

  // 클로즈 배열
  const closes = rows.map(r => +r[4]);

  // HMA(동시 세팅)
  const h50v  = hma(closes,50).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  const h100v = hma(closes,100).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  const h200v = hma(closes,200).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  h50.setData(h50v); h100.setData(h100v); h200.setData(h200v);

  // RSI(14, 고정)
  (function(){
    const len=14, out=[];
    let avgG=0, avgL=0;
    for(let i=1;i<closes.length;i++){
      const ch=closes[i]-closes[i-1], g=Math.max(ch,0), l=Math.max(-ch,0);
      if(i<=len){ avgG+=g; avgL+=l; if(i===len){ avgG/=len; avgL/=len; const rs=avgL===0?100:avgG/avgL; out.push({time:rtime[i], value:100-(100/(1+rs))}); } }
      else{ avgG=(avgG*(len-1)+g)/len; avgL=(avgL*(len-1)+l)/len; const rs=avgL===0?100:avgG/avgL; out.push({time:rtime[i], value:100-(100/(1+rs))}); }
    }
    rsiPane.setData(out);
  })();

  // OI
  try{
    const period = (TF.endsWith('m') ? TF : '5m'); // 근사
    const [od,op] = oiURL(SYMBOL, period, 600);
    const oij = await getJson(od,op);
    const oiData = oij.map(x=>({ time: Math.floor(new Date(x.timestamp).getTime()/1000), value: +x.sumOpenInterest }));
    oiPane.setData(oiData);
  }catch(e){ oiPane.setData([]); }

  // Bollinger Bands (20, 2σ)
  const bb = calcBB(closes, 20, 2);
  const bbU = bb.upper.map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  const bbM = bb.mid  .map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  const bbL = bb.lower.map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
  bbUpper.setData(bbU); bbMid.setData(bbM); bbLower.setData(bbL);

  chart.timeScale().fitContent();
}
syncToggles();
document.getElementById('symLabel').textContent = SYMBOL;
loadAll();
</script>
</body>
</html>
