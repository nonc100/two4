<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>COSMOS • Chart</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<style>
  :root{
    --bg:#0b1018; --panel:#0e1421; --text:#e8eefc; --muted:#9aa3b6;
    --up:#22c55e; --down:#ef4444; --chip:#1b2334; --chip-on:#2a3650;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(1200px 600px at 50% 0%, #182036 0%, var(--bg) 60%); color:var(--text); font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{height:100svh; display:flex; flex-direction:column}

  /* 상단: 심볼/가격 스트립 */
  .ticker{display:flex; align-items:center; gap:10px; padding:10px 12px; background:rgba(12,16,24,.55);
    border-bottom:1px solid rgba(255,255,255,.06); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px)}
  .sym{font-weight:900; letter-spacing:.04em; font-size:15px}
  .price{font-weight:900; font-variant-numeric:tabular-nums}
  .chg{font-weight:800; font-size:12px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.10)}
  .up{color:var(--up); background:rgba(34,197,94,.08)}
  .down{color:var(--down); background:rgba(239,68,68,.08)}
  .muted{color:var(--muted)}
  .spacer{flex:1}

  /* 타임프레임 바 */
  .tfbar{display:flex; gap:6px; padding:8px 12px; overflow-x:auto; border-bottom:1px solid rgba(255,255,255,.06); background:rgba(12,16,24,.35)}
  .chip{flex:0 0 auto; background:var(--chip); color:#dbeafe; border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:6px 10px; font-weight:700; cursor:pointer; user-select:none}
  .chip.on{background:var(--chip-on); border-color:rgba(114,153,255,.36)}
  .ghost{background:transparent; border-color:rgba(255,255,255,.14)}

  /* 차트 */
  #chart{flex:1; min-height:360px; position:relative}
  .chart-status{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; padding:24px; font-weight:700; letter-spacing:.12em; text-transform:uppercase; background:rgba(11,16,24,.78); backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px); border:1px solid rgba(148,163,184,.2); border-radius:18px; margin:18px; color:#cbd5ff; box-shadow:0 18px 48px rgba(0,0,0,.35); z-index:5; pointer-events:none;}
  .chart-status.muted{color:#94a3b8; border-color:rgba(148,163,184,.18)}
  .chart-status.error{color:#fda4af; border-color:rgba(248,113,113,.28); text-shadow:0 0 18px rgba(248,113,113,.35)}
  .chart-status.hidden{display:none}

  /* 하단 도크 */
  .dock{display:flex; gap:8px; align-items:center; justify-content:space-between; padding:8px 12px;
    background:rgba(12,16,24,.55); border-top:1px solid rgba(255,255,255,.06); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px)}
  .dock .group{display:flex; gap:6px; flex-wrap:wrap}

  @media (min-width:1024px){
    .ticker{padding:12px 18px}
    .tfbar{padding:10px 18px}
    .dock{padding:10px 18px}
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- 상단 심볼/가격 스트립 -->
  <div class="ticker">
    <div class="sym" id="symLabel">BTCUSDT</div>
    <div class="price" id="lastPrice">-</div>
    <div class="chg muted" id="pctChg">0.00%</div>
    <div class="spacer"></div>
  </div>

  <!-- 타임프레임 바 -->
  <div class="tfbar" id="tfBar">
    <div class="chip" data-tf="1m">1m</div>
    <div class="chip" data-tf="5m">5m</div>
    <div class="chip on" data-tf="15m">15m</div>
    <div class="chip" data-tf="30m">30m</div>
    <div class="chip" data-tf="1h">1h</div>
    <div class="chip" data-tf="4h">4h</div>
    <div class="chip" data-tf="1d">1d</div>
    <div class="chip" data-tf="1w">1w</div>
  </div>

  <!-- 차트 -->
  <div id="chart"></div>

  <!-- 하단 도크 -->
  <div class="dock">
    <div class="group">
      <div class="chip" id="togRSI">RSI</div>
      <div class="chip on" id="togOI">OI</div>
      <div class="chip" id="togHMA">HMA</div>
      <div class="chip" id="togBB">BB</div>
    </div>
    <div class="group">
      <div class="chip ghost" id="btnFit">Fit</div>
      <div class="chip ghost" id="btnReset">Reset</div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<script>
/* ===== 파라미터 ===== */
const qs=new URLSearchParams(location.search);
const idMap={bitcoin:'BTCUSDT',ethereum:'ETHUSDT',ripple:'XRPUSDT'};
let s=qs.get('sym')||qs.get('symbol');
if (s) s = s.trim();
if(!s){
  const id=qs.get('id');
  if(id) s=idMap[id.toLowerCase()]||id;
}
const SYMBOL=(s||'BTCUSDT').toUpperCase();
let TF=(qs.get('tf')||qs.get('interval')||'15m').toLowerCase();
const ID_HINT=(qs.get('id')||'').toLowerCase();

/* ===== Fetch 도우미 (직접 → 프록시) ===== */
async function getJson(direct, proxy){
  try{ const r=await fetch(direct); if(!r.ok) throw 0; return await r.json(); }
  catch{ const r2=await fetch(proxy); if(!r2.ok) throw new Error('fetch failed'); return await r2.json(); }
}
function tfLimit(tf){
  if (tf.endsWith('m')) return 1200;           // 1m/5m/15m/30m
  if (tf==='1h' || tf==='4h') return 1000;     // 바이낸스 최대 1000
  if (tf==='1d' || tf==='1w') return 1000;
  return 1000;
}
function chooseLimit(tf){
  const map = { '1m':1200,'5m':1200,'15m':1200,'30m':1000,'1h':1000,'4h':1000,'1d':1000,'1w':1000 };
  return Math.min(map[tf] || 500, 1000);
}
function klineURL(sym,tf,limit){
  limit = limit ?? tfLimit(tf);
  const q=`symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(tf)}&limit=${limit}`;
  return [
    `https://api.binance.com/api/v3/klines?${q}`,
    `/api/binance/klines?${q}`
  ];
}
function oiURL(sym,period='5m',limit=600){
  const q=`symbol=${sym}&period=${period}&limit=${limit}`;
  return [
    `https://fapi.binance.com/futures/data/openInterestHist?${q}`,
    `/api/binance/openInterestHist?${q}`
  ];
}

/* ===== 변환기 ===== */
const toCandle = k => ({ time:Number(k[0]), open:+k[1], high:+k[2], low:+k[3], close:+k[4] });
const toVolume = k => ({ time:Number(k[0]), value:+k[5], color:(+k[4] >= +k[1]) ? 'rgba(34,197,94,.55)' : 'rgba(239,68,68,.55)' });

const CG_SYMBOL_MAP={
  BTC:'bitcoin',BTCUSDT:'bitcoin',BTCUSD:'bitcoin',
  ETH:'ethereum',ETHUSDT:'ethereum',
  SOL:'solana',SOLUSDT:'solana',
  BNB:'binancecoin',BNBUSDT:'binancecoin',
  XRP:'ripple',XRPUSDT:'ripple',
  ADA:'cardano',ADAUSDT:'cardano',
  DOGE:'dogecoin',DOGEUSDT:'dogecoin',
  AVAX:'avalanche-2',AVAXUSDT:'avalanche-2',
  TRX:'tron',TRXUSDT:'tron',
  TON:'the-open-network',TONUSDT:'the-open-network',
  MATIC:'matic-network',MATICUSDT:'matic-network',
  DOT:'polkadot',DOTUSDT:'polkadot',
  LINK:'chainlink',LINKUSDT:'chainlink',
  LTC:'litecoin',LTCUSDT:'litecoin',
  OP:'optimism',OPUSDT:'optimism',
  ARB:'arbitrum',ARBUSDT:'arbitrum'
};

function guessCoinGeckoId(symbol){
  if(!symbol) return ID_HINT || '';
  const upper=symbol.toUpperCase();
  if(CG_SYMBOL_MAP[upper]) return CG_SYMBOL_MAP[upper];
  const base=upper.replace(/[-_]/g,'').replace(/(USDT|USDC|USD|BUSD|PERP)$/,'');
  if(CG_SYMBOL_MAP[base]) return CG_SYMBOL_MAP[base];
  return ID_HINT || base.toLowerCase();
}

function normalizeTimeline(baseRows, step, limit){
  if(!Array.isArray(baseRows) || !baseRows.length || !Number.isFinite(step)) return [];
  const rows=baseRows
    .filter(row=>Array.isArray(row) && row.length>=5)
    .map(row=>[
      Math.floor(Number(row[0])),
      Number(row[1]),
      Number(row[2]),
      Number(row[3]),
      Number(row[4]),
      Number(row[5] ?? 0)
    ])
    .filter(row=>row.every((v)=>Number.isFinite(v)));

  rows.sort((a,b)=>a[0]-b[0]);
  if(!rows.length) return [];

  const norm=[];
  for(let i=0;i<rows.length;i++){
    const cur=rows[i];
    norm.push(cur);
    if(i+1<rows.length){
      const nextTime=rows[i+1][0];
      const gapCount=Math.floor((nextTime-cur[0])/step)-1;
      if(gapCount>0 && gapCount<=3){
        for(let u=cur[0]+step; u<nextTime; u+=step){
          const prevClose=cur[4];
          norm.push([u,prevClose,prevClose,prevClose,prevClose,0]);
        }
      }
    }
  }

  const now=Math.floor(Date.now()/1000);
  let last=norm[norm.length-1];
  while(last && last[0]+step<=now && (!limit || norm.length<limit+20)){
    const prevClose=last[4];
    last=[last[0]+step,prevClose,prevClose,prevClose,prevClose,0];
    norm.push(last);
  }

  if(limit && norm.length>limit){
    norm.splice(0, norm.length-limit);
  }

  return norm;
}

async function fetchBinanceRows(symbol, tf){
  const limit=chooseLimit(tf);
  const [directUrl, proxyUrl]=klineURL(symbol, tf, limit);
  let rows=await getJson(directUrl, proxyUrl);
  if(rows && Array.isArray(rows.data)) rows=rows.data;
  if(!Array.isArray(rows)) throw new Error('invalid klines payload');
  if(!rows.length) return [];

  const step=TFSEC[tf] ?? 60;
  const snapMap=new Map();
  const normalizeTs=(val)=>{
    const num=Number(val);
    if(!Number.isFinite(num)) return null;
    return num>1e12 ? Math.floor(num/1000) : Math.floor(num);
  };

  for(const entry of rows){
    const ts=normalizeTs(entry?.[0]);
    if(!Number.isFinite(ts)) continue;
    const snapped=Math.floor(ts/step)*step;
    const norm=[
      snapped,
      Number(entry?.[1])||0,
      Number(entry?.[2])||Number(entry?.[1])||0,
      Number(entry?.[3])||Number(entry?.[1])||0,
      Number(entry?.[4])||Number(entry?.[1])||0,
      Number(entry?.[5])||0
    ];
    snapMap.set(snapped,norm);
  }

  const values=Array.from(snapMap.values());
  return normalizeTimeline(values, step, limit);
}

async function fetchCoinGeckoRows(symbol, tf){
  const id=guessCoinGeckoId(symbol);
  if(!id) throw new Error('unable to resolve CoinGecko id');
  const step=TFSEC[tf] ?? 60;
  const limit=chooseLimit(tf);
  const nowSec=Math.floor(Date.now()/1000);
  const span=step*(limit+Math.min(limit,240));
  const fromSec=Math.max(0, nowSec-span);
  const url=`https://api.coingecko.com/api/v3/coins/${encodeURIComponent(id)}/market_chart/range?vs_currency=usd&from=${fromSec}&to=${nowSec}`;

  const res=await fetch(url);
  if(!res.ok) throw new Error(`coingecko http ${res.status}`);
  const data=await res.json();
  const priceArr=Array.isArray(data?.prices)?data.prices:[];
  if(!priceArr.length) throw new Error('coingecko prices empty');

  const buckets=new Map();
  for(const entry of priceArr){
    if(!Array.isArray(entry)||entry.length<2) continue;
    const ts=Math.floor(Number(entry[0])/1000);
    const price=Number(entry[1]);
    if(!Number.isFinite(ts)||!Number.isFinite(price)) continue;
    const bucketTime=Math.floor(ts/step)*step;
    let bucket=buckets.get(bucketTime);
    if(!bucket){
      bucket={ time:bucketTime, open:price, high:price, low:price, close:price, first:ts, last:ts, volume:0 };
      buckets.set(bucketTime,bucket);
    }else{
      if(ts<bucket.first){ bucket.first=ts; bucket.open=price; }
      if(ts>=bucket.last){ bucket.last=ts; bucket.close=price; }
      if(price>bucket.high) bucket.high=price;
      if(price<bucket.low) bucket.low=price;
    }
  }

  const volumes=Array.isArray(data?.total_volumes)?data.total_volumes:[];
  for(let i=1;i<volumes.length;i++){
    const prev=volumes[i-1];
    const cur=volumes[i];
    if(!Array.isArray(prev)||!Array.isArray(cur)) continue;
    const curTs=Math.floor(Number(cur[0])/1000);
    const delta=Number(cur[1])-Number(prev[1]);
    if(!Number.isFinite(curTs)||!Number.isFinite(delta)) continue;
    const bucketTime=Math.floor(curTs/step)*step;
    const bucket=buckets.get(bucketTime);
    if(bucket) bucket.volume += Math.max(0, delta);
  }

  const baseRows=[];
  const times=Array.from(buckets.keys()).sort((a,b)=>a-b);
  let prevClose=null;
  for(const t of times){
    const bucket=buckets.get(t);
    const open=Number.isFinite(bucket.open)?bucket.open:(prevClose??0);
    const close=Number.isFinite(bucket.close)?bucket.close:open;
    const high=Number.isFinite(bucket.high)?bucket.high:Math.max(open,close);
    const low=Number.isFinite(bucket.low)?bucket.low:Math.min(open,close);
    const vol=Number(bucket.volume)||0;
    baseRows.push([t,open,high,low,close,vol]);
    prevClose=close;
  }

  return normalizeTimeline(baseRows, step, limit);
}

/* ===== 수학: WMA/HMA & SMA/STD & BB & RSI ===== */
function wma(values, period){
  const out=[]; const w=period*(period+1)/2;
  for(let i=0;i<values.length;i++){
    if(i<period-1){ out.push(null); continue; }
    let sum=0, weight=period;
    for(let k=0;k<period;k++) sum += values[i-k]*weight-- ;
    out.push(sum/w);
  }
  return out;
}
function hma(values, period){
  const half=Math.floor(period/2), sqrt=Math.max(2, Math.floor(Math.sqrt(period)));
  const wmaHalf = wma(values, half);
  const wmaFull = wma(values, period);
  const diff = values.map((_,i)=>{
    const a=wmaHalf[i]??null, b=wmaFull[i]??null;
    return (a==null || b==null)?null:(2*a - b);
  });
  return wma(diff, sqrt);
}
function sma(values, period){
  const out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=period) sum -= values[i-period];
    out.push(i>=period-1 ? sum/period : null);
  }
  return out;
}
function std(values, period){
  const out=[]; let sum=0, sumsq=0;
  for(let i=0;i<values.length;i++){
    const v=values[i]; sum += v; sumsq += v*v;
    if(i>=period){ const old=values[i-period]; sum -= old; sumsq -= old*old; }
    if(i>=period-1){
      const mean = sum/period;
      out.push(Math.sqrt(Math.max(0, (sumsq/period) - mean*mean )));
    }else out.push(null);
  }
  return out;
}
function calcBB(close, period=20, mult=2){
  const m = sma(close, period);
  const s = std(close, period);
  const upper=[], lower=[];
  for(let i=0;i<close.length;i++){
    const mi=m[i], si=s[i];
    upper.push(mi==null?null:mi+mult*si);
    lower.push(mi==null?null:mi-mult*si);
  }
  return {mid:m, upper, lower};
}

/* ===== 차트 생성 - UTC 시간대로 수정 ===== */
const root = document.getElementById('chart');
const statusBox = document.createElement('div');
statusBox.id = 'chartStatus';
statusBox.className = 'chart-status hidden muted';
statusBox.textContent = 'Loading...';
root.appendChild(statusBox);

function showStatus(message, tone='muted'){
  statusBox.textContent = message;
  statusBox.classList.remove('hidden','muted','error');
  statusBox.classList.add(tone === 'error' ? 'error' : 'muted');
}

function hideStatus(){
  statusBox.classList.add('hidden');
}

const chart = LightweightCharts.createChart(root,{
  layout:{ background:{ type:'solid', color:'transparent' }, textColor:'#dfe8ff' },
  grid:{ vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
  rightPriceScale:{ borderVisible:false, scaleMargins:{ top:0.10, bottom:0.22 } },
  timeScale:{ borderVisible:false, rightOffset:8, timeVisible:true, timezone:'Asia/Seoul' },
  crosshair:{ mode:LightweightCharts.CrosshairMode.Normal, vertLine:{color:'rgba(255,255,255,.25)'}, horzLine:{color:'rgba(255,255,255,.25)'} },
  watermark:{ visible:true, text:'TWO.4', fontSize:22, color:'rgba(255,255,255,.14)', horzAlign:'right', vertAlign:'top' }
});
const mainSeries = chart.addCandlestickSeries({
  upColor:'#22c55e', downColor:'#ef4444', borderVisible:false, wickUpColor:'#22c55e', wickDownColor:'#ef4444',
  lastValueVisible:true, priceLineVisible:true, priceLineColor:'#6aa3ff'
});

/* 더 작은 볼륨(칸식) */
const volSeries = chart.addHistogramSeries({
  priceScaleId:'', priceFormat:{type:'volume'}, color:'rgba(180,200,255,.35)',
  priceLineVisible:false, lastValueVisible:false, overlay:true, base:0
});
chart.priceScale('').applyOptions({ scaleMargins:{ top:0.93, bottom:0 }});

/* 보조지표 패널 */
const rsiPane = chart.addLineSeries({ 
  color:'#7aa5ff', lineWidth:2, priceScaleId:'rsi', 
  lastValueVisible:false, priceLineVisible:false 
});
chart.priceScale('rsi').applyOptions({ scaleMargins:{ top:0.70, bottom:0.12 }, borderVisible:false });

const oiPane = chart.addLineSeries({ 
  color:'#b397ff', lineWidth:2, priceScaleId:'oi', 
  lastValueVisible:false, priceLineVisible:false 
});
chart.priceScale('oi').applyOptions({ scaleMargins:{ top:0.86, bottom:0.02 }, borderVisible:false });

/* HMA 3종 (동시 토글, 굵기 1) */
const h50  = chart.addLineSeries({ color:'#ff4d4d', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const h100 = chart.addLineSeries({ color:'#ffd24d', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const h200 = chart.addLineSeries({ color:'#7dd3fc', lineWidth:1, lastValueVisible:false, priceLineVisible:false });

/* 볼린저밴드 3선 */
const bbUpper = chart.addLineSeries({ color:'rgba(122,165,255,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const bbMid   = chart.addLineSeries({ color:'rgba(200,210,230,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });
const bbLower = chart.addLineSeries({ color:'rgba(122,165,255,.9)', lineWidth:1, lastValueVisible:false, priceLineVisible:false });

/* UI 세팅 */
document.getElementById('symLabel').textContent = SYMBOL;

/* TF 바 동작 */
const tfChips = Array.from(document.querySelectorAll('#tfBar .chip'));
function syncTFUI(){ tfChips.forEach(c=>c.classList.toggle('on', c.dataset.tf===TF)); }
tfChips.forEach(c=>c.onclick=()=>{ TF=c.dataset.tf; syncTFUI(); loadAll(); });

/* 토글 */
const togRSI  = document.getElementById('togRSI');
const togOI   = document.getElementById('togOI');
const togHMA  = document.getElementById('togHMA');
const togBB   = document.getElementById('togBB');

let showRSI=false, showOI=true, showHMA=false, showBB=false;
function syncToggles(){
  togRSI.classList.toggle('on',showRSI);
  togOI.classList.toggle('on',showOI);
  togHMA.classList.toggle('on',showHMA);
  togBB.classList.toggle('on',showBB);
  rsiPane.applyOptions({visible:showRSI});
  oiPane.applyOptions({visible:showOI});
  h50.applyOptions({visible:showHMA});
  h100.applyOptions({visible:showHMA});
  h200.applyOptions({visible:showHMA});
  bbUpper.applyOptions({visible:showBB});
  bbMid.applyOptions({visible:showBB});
  bbLower.applyOptions({visible:showBB});
}
[togRSI,togOI,togHMA,togBB].forEach(btn=>{
  btn.onclick=()=>{ 
    if(btn===togRSI) showRSI=!showRSI;
    if(btn===togOI) showOI=!showOI;
    if(btn===togHMA) showHMA=!showHMA;
    if(btn===togBB)  showBB=!showBB;
    syncToggles();
  };
});

/* Fit / Reset */
document.getElementById('btnFit').onclick = ()=> chart.timeScale().fitContent();
document.getElementById('btnReset').onclick = ()=> { chart.timeScale().setVisibleRange({from:undefined,to:undefined}); chart.timeScale().fitContent(); };

// --- TF별 간격(초) ---
const TFSEC = { '1m':60,'5m':300,'15m':900,'30m':1800,'1h':3600,'4h':14400,'1d':86400,'1w':604800 };

function lastItem(arr){
  return Array.isArray(arr) && arr.length ? arr[arr.length - 1] : undefined;
}
function nthFromEnd(arr, n){
  if (!Array.isArray(arr)) return undefined;
  const idx = arr.length - 1 - n;
  return idx >= 0 ? arr[idx] : undefined;
}

function clearAllSeries(){
  mainSeries.setData([]);
  volSeries.setData([]);
  rsiPane.setData([]);
  oiPane.setData([]);
  h50.setData([]);
  h100.setData([]);
  h200.setData([]);
  bbUpper.setData([]);
  bbMid.setData([]);
  bbLower.setData([]);
}

/* 로더 - 결측 구간 처리 개선 */
async function loadAll(){
  syncTFUI();
  showStatus('Loading...', 'muted');
  let rowsNorm=[];
  let usingFallback=false;
  let binanceError=null;

  try{
    try{
      rowsNorm = await fetchBinanceRows(SYMBOL, TF);
    }catch(err){
      binanceError = err;
      console.warn('[chart] binance fetch failed:', err?.message || err);
    }

    if(!rowsNorm || !rowsNorm.length){
      try{
        showStatus('CoinGecko 데이터로 대체 로딩 중…', 'muted');
        rowsNorm = await fetchCoinGeckoRows(SYMBOL, TF);
        usingFallback = true;
      }catch(fallbackErr){
        console.error('chart load failed', fallbackErr);
        if(binanceError) console.error('primary binance error:', binanceError);
        clearAllSeries();
        showStatus('차트를 불러오지 못했습니다', 'error');
        return;
      }
    }

    if(!rowsNorm || !rowsNorm.length){
      clearAllSeries();
      showStatus('데이터가 없습니다', 'muted');
      return;
    }

    const candles = rowsNorm.map(toCandle);
    const volumes = rowsNorm.map(toVolume);
    mainSeries.setData(candles);
    volSeries.setData(volumes);
    chart.timeScale().fitContent();

    if(usingFallback){
      console.info('[chart] CoinGecko fallback active for', SYMBOL, TF);
    }

    const steps = [...new Set(candles.slice(1).map((b,i)=>candles[i+1].time - candles[i].time))];
    console.log('uniq steps:', steps);

    const firstCandle = candles[0];
    const lastCandle = lastItem(candles);
    if (firstCandle && lastCandle) {
      console.log('[candles]', TF, candles.length, 'from', new Date(firstCandle.time*1000).toISOString(), 'to', new Date(lastCandle.time*1000).toISOString());
    }
    for(let i=1;i<Math.min(candles.length,50);i++){
      const d=candles[i].time - candles[i-1].time;
      if(d !== TFSEC[TF]){ console.warn('STEP MISMATCH at', i, 'Δ', d); break; }
    }

    const last = lastCandle;
    const prev = nthFromEnd(candles, 1) || last;
    const lastPrice = last?.close ?? 0;
    const prevClose = prev?.close ?? lastPrice;
    if (!last || !Number.isFinite(lastPrice) || !Number.isFinite(prevClose)) {
      showStatus('가격 데이터를 불러오지 못했습니다', 'error');
      return;
    }
    const pct = prevClose !== 0 ? ((lastPrice - prevClose)/prevClose)*100 : 0;
    document.getElementById('lastPrice').textContent = lastPrice.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
    const chg = document.getElementById('pctChg');
    chg.textContent = (pct>=0?'+':'') + pct.toFixed(2) + '%';
    chg.className = 'chg ' + (pct>=0?'up':'down');

    const rtime = rowsNorm.map(r => Number(r[0]));
    const closes = candles.map(c=>c.close);

    const h50v  = hma(closes,50).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
    const h100v = hma(closes,100).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
    const h200v = hma(closes,200).map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean);
    h50.setData(h50v); h100.setData(h100v); h200.setData(h200v);

    (function(){
      const len=14, out=[];
      let avgG=0, avgL=0;
      for(let i=1;i<closes.length;i++){
        const ch=closes[i]-closes[i-1], g=Math.max(ch,0), l=Math.max(-ch,0);
        if(i<=len){ avgG+=g; avgL+=l; if(i===len){ avgG/=len; avgL/=len; const rs=avgL===0?100:avgG/avgL; out.push({time:rtime[i], value:100-(100/(1+rs))}); } }
        else{ avgG=(avgG*(len-1)+g)/len; avgL=(avgL*(len-1)+l)/len; const rs=avgL===0?100:avgG/avgL; out.push({time:rtime[i], value:100-(100/(1+rs))}); }
      }
      rsiPane.setData(out);
    })();

    const bb = calcBB(closes, 20, 2);
    bbUpper.setData(bb.upper.map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean));
    bbMid  .setData(bb.mid  .map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean));
    bbLower.setData(bb.lower.map((v,i)=>v==null?null:{time:rtime[i], value:v}).filter(Boolean));

    try{
      const period = (TF.endsWith('m') ? TF : '5m');
      const [od,op] = oiURL(SYMBOL, period, 600);
      const oij = await getJson(od,op);
      const oiData = oij.map(x=>({ time: Math.floor(new Date(x.timestamp).getTime()/1000), value: +x.sumOpenInterest }));
      oiPane.setData(oiData);
    }catch(e){ oiPane.setData([]); }

    hideStatus();
  }catch(err){
    console.error('chart load failed', err);
    if(binanceError) console.error('primary binance error:', binanceError);
    clearAllSeries();
    showStatus('차트를 불러오지 못했습니다', 'error');
  }
}
syncToggles();
document.getElementById('symLabel').textContent = SYMBOL;
loadAll();
</script>
</body>
</html>
