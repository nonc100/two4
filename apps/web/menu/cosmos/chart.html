<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>COSMOS • Market View</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <style>
    :root{
      color-scheme:dark;
      --bg:#05080f; --panel:#0c121f; --panel-strong:#0f1626; --border:rgba(120,141,187,.18);
      --text:#f4f7ff; --muted:#9ca6bf; --accent:#60a5fa; --accent-soft:rgba(96,165,250,.15);
      --up:#22c55e; --down:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:radial-gradient(1600px 800px at 50% -20%,rgba(78,115,220,.18) 0%,var(--bg) 60%);color:var(--text);font:14px/1.5 "Pretendard",system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;min-height:100%;}
    body{display:flex;justify-content:center;}
    .shell{width:min(1200px,100vw);min-height:100vh;display:flex;flex-direction:column;background:linear-gradient(155deg,rgba(15,24,42,.7),rgba(9,14,26,.82));backdrop-filter:blur(24px);-webkit-backdrop-filter:blur(24px);box-shadow:0 40px 120px rgba(4,9,20,.45);}

    header{padding:18px clamp(16px,2vw,28px);display:flex;flex-wrap:wrap;gap:14px;align-items:center;border-bottom:1px solid var(--border);background:linear-gradient(180deg,rgba(24,34,57,.68),rgba(12,17,30,.76));}
    header .brand{font-weight:800;letter-spacing:.04em;text-transform:uppercase;font-size:16px;padding-right:10px;border-right:1px solid rgba(255,255,255,.08);}
    header .pair{display:flex;flex-direction:column;gap:4px;}
    header .pair .symbol{font-size:18px;font-weight:800;letter-spacing:.08em;}
    header .pair .price{font-size:22px;font-variant-numeric:tabular-nums;font-weight:900;}
    header .pair .delta{font-size:12px;font-weight:700;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);align-self:flex-start;}
    header .meta{margin-left:auto;display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted);text-align:right;}

    .toolbar{display:flex;flex-wrap:wrap;gap:10px;padding:12px clamp(16px,2vw,24px);border-bottom:1px solid var(--border);background:rgba(10,15,25,.72);}
    .toolbar .group{display:flex;gap:6px;flex-wrap:wrap;}
    button.chip{appearance:none;border:1px solid rgba(255,255,255,.15);background:rgba(12,18,30,.6);color:inherit;border-radius:14px;padding:6px 12px;font-weight:700;font-size:12px;letter-spacing:.02em;cursor:pointer;transition:all .2s ease;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);}
    button.chip:hover{border-color:rgba(96,165,250,.7);box-shadow:0 0 0 1px rgba(96,165,250,.25);}
    button.chip.active{background:var(--accent-soft);border-color:rgba(96,165,250,.55);color:#bfdbfe;}
    button.chip.ghost{background:transparent;color:var(--muted);}    

    main{flex:1;display:flex;flex-direction:column;min-height:400px;}
    #chart{flex:1;min-height:360px;}
    .status-line{display:flex;justify-content:space-between;align-items:center;padding:10px clamp(16px,2vw,24px);font-size:12px;color:var(--muted);border-top:1px solid rgba(255,255,255,.06);background:rgba(6,10,18,.75);gap:10px;flex-wrap:wrap;}
    .status-line .info{display:flex;gap:14px;flex-wrap:wrap;}
    .status-line span{font-variant-numeric:tabular-nums;}

    @media (max-width:640px){
      header{align-items:flex-start;}
      header .meta{text-align:left;width:100%;order:3;margin-left:0;padding-top:4px;}
      header .pair .price{font-size:20px;}
      .toolbar{position:sticky;top:0;z-index:3;}
      .status-line{font-size:11px;}
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="brand">cosmos</div>
      <div class="pair">
        <span class="symbol" id="symbolLabel">BTC · USDT</span>
        <span class="price" id="priceLabel">-</span>
        <span class="delta" id="deltaLabel">0.00%</span>
      </div>
      <div class="meta">
        <span id="updatedLabel">Updated · -</span>
        <span>Source · Binance</span>
      </div>
    </header>

    <div class="toolbar" id="tfBar"></div>
    <div class="toolbar" id="indBar"></div>

    <main>
      <div id="chart"></div>
    </main>

    <div class="status-line">
      <div class="info">
        <span id="ohlcLabel">O: - H: - L: - C: -</span>
        <span id="volLabel">Volume: -</span>
      </div>
      <div class="info">
        <span id="statusLabel">Loading...</span>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  const qs = new URLSearchParams(location.search);
  const aliasMap = { bitcoin:'BTCUSDT', ethereum:'ETHUSDT', ripple:'XRPUSDT' };
  let rawSymbol = qs.get('sym') || qs.get('symbol') || qs.get('pair');
  let derived = rawSymbol ? rawSymbol.trim().toUpperCase() : null;
  if(!derived){
    const id = qs.get('id');
    if(id) derived = aliasMap[id.toLowerCase()] || id.toUpperCase();
  }
  const SYMBOL = (derived || 'BTCUSDT').toUpperCase();
  let TF = (qs.get('tf') || qs.get('interval') || '15m').toLowerCase();

  const TF_SET = [
    {label:'1m',value:'1m'},
    {label:'5m',value:'5m'},
    {label:'15m',value:'15m'},
    {label:'30m',value:'30m'},
    {label:'1H',value:'1h'},
    {label:'4H',value:'4h'},
    {label:'1D',value:'1d'},
    {label:'1W',value:'1w'}
  ];

  const INDICATORS = [
    {label:'Volume', value:'volume', default:true},
    {label:'Open Interest', value:'oi', default:true},
    {label:'RSI', value:'rsi'},
    {label:'HMA', value:'hma'},
    {label:'Bollinger Bands', value:'bb'}
  ];

  const LIMITS = { '1m':1200,'5m':1200,'15m':1200,'30m':1000,'1h':1000,'4h':1000,'1d':750,'1w':520 };

  const tfBar = document.getElementById('tfBar');
  const indBar = document.getElementById('indBar');
  const statusLabel = document.getElementById('statusLabel');
  const ohlcLabel = document.getElementById('ohlcLabel');
  const volLabel = document.getElementById('volLabel');
  const priceLabel = document.getElementById('priceLabel');
  const deltaLabel = document.getElementById('deltaLabel');
  const updatedLabel = document.getElementById('updatedLabel');
  const symbolLabel = document.getElementById('symbolLabel');

  const indicatorState = {};

  symbolLabel.textContent = SYMBOL.replace('USDT',' · USDT');

  function formatNumber(v, digits = 2){
    if(!isFinite(v)) return '-';
    if(Math.abs(v) >= 1000){
      return new Intl.NumberFormat('en-US',{notation:'compact',maximumFractionDigits:digits}).format(v);
    }
    return Number(v).toLocaleString('en-US',{maximumFractionDigits:digits});
  }

  function timeFmt(ts){
    const d = new Date(ts);
    return d.toLocaleString('ko-KR',{hour12:false});
  }

  function createChip(text, value, active=false){
    const btn = document.createElement('button');
    btn.className = 'chip' + (active?' active':'');
    btn.textContent = text;
    btn.dataset.value = value;
    return btn;
  }

  TF_SET.forEach(cfg=>{
    const chip = createChip(cfg.label, cfg.value, cfg.value===TF);
    chip.addEventListener('click',()=>{
      if(TF===cfg.value) return;
      TF = cfg.value;
      updateTFActive();
      loadAndRender();
    });
    tfBar.appendChild(chip);
  });

  function updateTFActive(){
    tfBar.querySelectorAll('button').forEach(btn=>{
      btn.classList.toggle('active', btn.dataset.value === TF);
    });
  }

  INDICATORS.forEach(cfg=>{
    indicatorState[cfg.value] = !!cfg.default;
    const chip = createChip(cfg.label, cfg.value, !!cfg.default);
    chip.addEventListener('click',()=>{
      indicatorState[cfg.value] = !indicatorState[cfg.value];
      chip.classList.toggle('active', indicatorState[cfg.value]);
      renderOverlays();
    });
    indBar.appendChild(chip);
  });

  const chart = LightweightCharts.createChart(document.getElementById('chart'),{
    layout:{background:{type:'solid',color:'transparent'},textColor:'#dfe6ff'},
    rightPriceScale:{borderVisible:false},
    leftPriceScale:{visible:false},
    overlayPriceScales:{mode:0},
    timeScale:{borderVisible:false,timeVisible:true,secondsVisible:false},
    grid:{vertLines:{color:'rgba(148,163,184,.12)'},horzLines:{color:'rgba(148,163,184,.08)'}},
    crosshair:{mode:LightweightCharts.CrosshairMode.Normal}
  });

  const mainSeries = chart.addCandlestickSeries({upColor:'#22c55e',borderUpColor:'#22c55e',wickUpColor:'#22c55e',downColor:'#ef4444',borderDownColor:'#ef4444',wickDownColor:'#ef4444'});
  const volumeSeries = chart.addHistogramSeries({priceScaleId:'',priceFormat:{type:'volume'},priceLineVisible:false,color:'rgba(255,255,255,.4)',overlay:true,scaleMargins:{top:0.8,bottom:0}});
  const oiSeries = chart.addLineSeries({color:'#f97316',lineWidth:2,priceScaleId:'oi',title:'OI'});
  oiSeries.priceScale().applyOptions({position:'left',scaleMargins:{top:0.85,bottom:0}});

  let bbSeries, bbUpper, bbLower, hmaSeries, rsiPane, rsiSeries;

  const panes = {
    ensureRSI(){
      if(rsiPane) return;
      rsiPane = chart.addPriceScale('rsi');
      rsiSeries = chart.addLineSeries({priceScaleId:'rsi',color:'#38bdf8',lineWidth:2});
      rsiSeries.priceScale().applyOptions({position:'left',scaleMargins:{top:0.6,bottom:0}});
    },
    dropRSI(){
      if(!rsiSeries) return;
      chart.removeSeries(rsiSeries);
      rsiSeries = null;
      rsiPane = null;
    }
  };

  chart.subscribeCrosshairMove(param=>{
    if(!param || !param.time || !param.seriesData) return;
    const candle = param.seriesData.get(mainSeries);
    if(candle){
      ohlcLabel.textContent = `O: ${formatNumber(candle.open,4)}  H: ${formatNumber(candle.high,4)}  L: ${formatNumber(candle.low,4)}  C: ${formatNumber(candle.close,4)}`;
    }
    const vol = param.seriesData.get(volumeSeries);
    if(vol){
      volLabel.textContent = `Volume: ${formatNumber(vol.value,2)}`;
    }
  });

  async function getJson(primary, fallback){
    try{
      const res = await fetch(primary);
      if(!res.ok) throw new Error('Primary failed');
      return await res.json();
    }catch(err){
      if(!fallback) throw err;
      const res2 = await fetch(fallback);
      if(!res2.ok) throw new Error('Fallback failed');
      return await res2.json();
    }
  }

  function klineURL(symbol, tf, limit){
    const params = new URLSearchParams({symbol, interval:tf, limit:String(limit)});
    return [
      `https://api.binance.com/api/v3/klines?${params}`,
      `/api/binance/klines?${params}`
    ];
  }

  function oiURL(symbol, period='5m', limit=600){
    const params = new URLSearchParams({symbol, period, limit:String(limit)});
    return [
      `https://fapi.binance.com/futures/data/openInterestHist?${params}`,
      `/api/binance/openInterestHist?${params}`
    ];
  }

  function mapCandles(raw){
    return raw.map(k=>({
      time:Number(k[0]) / 1000,
      open:+k[1],
      high:+k[2],
      low:+k[3],
      close:+k[4],
      volume:+k[5]
    }));
  }

  function toHistogram(candles){
    return candles.map(c=>({
      time:c.time,
      value:c.volume,
      color:c.close >= c.open ? 'rgba(34,197,94,.45)' : 'rgba(239,68,68,.45)'
    }));
  }

  function sma(values, period){
    const out=[]; let sum=0;
    for(let i=0;i<values.length;i++){
      sum += values[i];
      if(i>=period) sum -= values[i-period];
      out[i] = i>=period-1 ? sum/period : null;
    }
    return out;
  }

  function wma(values, period){
    const out=[]; const norm = period*(period+1)/2;
    for(let i=0;i<values.length;i++){
      if(i<period-1){ out.push(null); continue; }
      let acc=0, weight=period;
      for(let k=0;k<period;k++){
        acc += values[i-k]*weight--;
      }
      out.push(acc/norm);
    }
    return out;
  }

  function hma(values, period){
    const half=Math.floor(period/2), sqrt=Math.max(2,Math.floor(Math.sqrt(period)));
    const wmaHalf=wma(values,half);
    const wmaFull=wma(values,period);
    const diff=values.map((_,i)=>{
      const a=wmaHalf[i], b=wmaFull[i];
      return (a==null||b==null)?null:(2*a-b);
    });
    return wma(diff,sqrt);
  }

  function bb(values, period=20, mult=2){
    const mean = sma(values, period);
    const upper=[], lower=[];
    for(let i=0;i<values.length;i++){
      if(i<period-1){ upper.push(null); lower.push(null); continue; }
      let sumSq=0;
      for(let k=0;k<period;k++){
        const diff = values[i-k]-mean[i];
        sumSq += diff*diff;
      }
      const dev=Math.sqrt(sumSq/period);
      upper.push(mean[i]+mult*dev);
      lower.push(mean[i]-mult*dev);
    }
    return {basis:mean, upper, lower};
  }

  function rsi(values, period=14){
    const out=[];
    let gains=0, losses=0;
    for(let i=1;i<values.length;i++){
      const diff = values[i]-values[i-1];
      const gain = diff>0?diff:0;
      const loss = diff<0?Math.abs(diff):0;
      if(i<=period){
        gains += gain; losses += loss;
        out.push(null);
      }else if(i===period+1){
        gains = (gains + gain)/period;
        losses = (losses + loss)/period;
        out.push(losses===0?100:100 - 100/(1+gains/losses));
      }else{
        gains = (gains*(period-1)+gain)/period;
        losses = (losses*(period-1)+loss)/period;
        out.push(losses===0?100:100 - 100/(1+gains/losses));
      }
    }
    out.unshift(null);
    return out;
  }

  let candleData=[], volumeData=[], oiData=[];

  async function loadAndRender(){
    statusLabel.textContent = 'Loading data…';
    try{
      const [candleRaw, oiRaw] = await Promise.all([
        (async()=>{
          const limit = LIMITS[TF] || 600;
          const [p,f] = klineURL(SYMBOL, TF, limit);
          return await getJson(p,f);
        })(),
        indicatorState.oi ? (async()=>{ const [p,f]=oiURL(SYMBOL,'5m',600); return await getJson(p,f); })() : Promise.resolve(null)
      ]);

      candleData = mapCandles(candleRaw);
      volumeData = toHistogram(candleData);

      mainSeries.setData(candleData);
      volumeSeries.setData(indicatorState.volume ? volumeData : []);

      const last = candleData[candleData.length-1];
      if(last){
        priceLabel.textContent = formatNumber(last.close, last.close > 10 ? 2 : 4);
        const first = candleData[0];
        if(first){
          const pct = ((last.close-first.open)/first.open)*100;
          deltaLabel.textContent = `${pct>=0?'+':''}${pct.toFixed(2)}%`;
          deltaLabel.style.background = pct>=0? 'rgba(34,197,94,.12)' : 'rgba(239,68,68,.12)';
          deltaLabel.style.color = pct>=0? '#4ade80' : '#fca5a5';
        }
        updatedLabel.textContent = `Updated · ${timeFmt(last.time*1000)}`;
      }

      if(indicatorState.oi && Array.isArray(oiRaw)){
        oiData = oiRaw.map(item=>({
          time: Number(item.timestamp)/1000,
          value: Number(item.sumOpenInterestValue)
        })).sort((a,b)=>a.time-b.time);
        oiSeries.setData(oiData);
      }else{
        oiSeries.setData([]);
      }

      renderOverlays();
      statusLabel.textContent = `Loaded · ${candleData.length} candles (${TF.toUpperCase()})`;
    }catch(err){
      console.error(err);
      statusLabel.textContent = 'Failed to load data';
    }
  }

  function renderOverlays(){
    if(!candleData.length) return;
    const closes = candleData.map(c=>c.close);

    if(indicatorState.volume){
      volumeSeries.setData(volumeData);
    }else{
      volumeSeries.setData([]);
    }

    if(indicatorState.bb){
      if(!bbSeries){
        bbSeries = chart.addLineSeries({color:'#94a3b8',lineWidth:1,priceLineVisible:false});
        bbUpper = chart.addLineSeries({color:'rgba(96,165,250,.75)',lineWidth:1,priceLineVisible:false});
        bbLower = chart.addLineSeries({color:'rgba(96,165,250,.75)',lineWidth:1,priceLineVisible:false});
      }
      const bands = bb(closes,20,2);
      const mapLine = (values)=>candleData.map((c,i)=>({time:c.time,value:values[i]})).filter(d=>d.value!=null);
      bbSeries.setData(mapLine(bands.basis));
      bbUpper.setData(mapLine(bands.upper));
      bbLower.setData(mapLine(bands.lower));
    }else if(bbSeries){
      chart.removeSeries(bbSeries); chart.removeSeries(bbUpper); chart.removeSeries(bbLower);
      bbSeries=bbUpper=bbLower=null;
    }

    if(indicatorState.hma){
      if(!hmaSeries){
        hmaSeries = chart.addLineSeries({color:'#a855f7',lineWidth:2});
      }
      const values = hma(closes, 34).map((v,i)=>({time:candleData[i].time,value:v})).filter(d=>d.value!=null);
      hmaSeries.setData(values);
    }else if(hmaSeries){
      chart.removeSeries(hmaSeries);
      hmaSeries=null;
    }

    if(indicatorState.rsi){
      panes.ensureRSI();
      const rsiVals = rsi(closes,14).map((v,i)=>({time:candleData[i].time,value:v})).filter(d=>d.value!=null);
      rsiSeries.setData(rsiVals);
    }else{
      panes.dropRSI();
    }

    if(indicatorState.oi){
      if(oiData.length){
        oiSeries.setData(oiData);
      }
    }else{
      oiSeries.setData([]);
    }
  }

  loadAndRender();
  setInterval(loadAndRender, 60_000);
  </script>
</body>
</html>
